{% extends "base.html" %}

{% block title %}Game {{ code }} - Among Us IRL{% endblock %}

{% block content %}
<div class="container">
    <!-- Lobby Screen -->
    <div id="lobby-screen" class="screen">
        <div class="game-code-display">
            <span class="label">Game Code</span>
            <span class="code" id="display-code">{{ code }}</span>
        </div>

        <div class="players-section">
            <h2>Players <span id="player-count">(0)</span></h2>
            <div id="player-list" class="player-list"></div>
        </div>

        <div id="host-controls" class="host-controls" style="display: none;">
            <h3>Settings</h3>
            <div class="settings-grid">
                <div class="setting">
                    <label>Tasks per player</label>
                    <div class="number-control">
                        <button class="btn-small" onclick="adjustSetting('tasks', -1)">-</button>
                        <span id="setting-tasks">5</span>
                        <button class="btn-small" onclick="adjustSetting('tasks', 1)">+</button>
                    </div>
                </div>
                <div class="setting">
                    <label>Impostors</label>
                    <div class="number-control">
                        <button class="btn-small" onclick="adjustSetting('impostors', -1)">-</button>
                        <span id="setting-impostors">2</span>
                        <button class="btn-small" onclick="adjustSetting('impostors', 1)">+</button>
                    </div>
                </div>
            </div>

            <!-- Advanced Roles Settings -->
            <div class="advanced-roles-settings">
                <div class="section-header" onclick="toggleAdvancedRoles()">
                    <h4>Advanced Roles</h4>
                    <span id="advanced-roles-toggle-icon">-</span>
                </div>
                <div id="advanced-roles-content" style="display: block;">
                    <!-- Crewmate Variants -->
                    <div class="role-category">
                        <h5 class="category-crew">Crewmate Variants</h5>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="toggle-sheriff" onchange="toggleRole('sheriff')">
                                <span>Sheriff</span>
                            </label>
                            <span class="role-desc">Shoot impostors (miss = die)</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-engineer" onchange="toggleAdvancedRole('engineer')">
                                <span>Engineer</span>
                            </label>
                            <span class="role-desc">Fix one sabotage remotely</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-captain" onchange="toggleAdvancedRole('captain')">
                                <span>Captain</span>
                            </label>
                            <span class="role-desc">Remote meeting from anywhere</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-mayor" onchange="toggleAdvancedRole('mayor')">
                                <span>Mayor</span>
                            </label>
                            <span class="role-desc">Vote counts twice</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-nice_guesser" onchange="toggleAdvancedRole('nice_guesser')">
                                <span>Bounty Hunter</span>
                            </label>
                            <span class="role-desc">Guess roles (risky!)</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-spy" onchange="toggleAdvancedRole('spy')">
                                <span>Spy</span>
                            </label>
                            <span class="role-desc">Appears as impostor</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-swapper" onchange="toggleAdvancedRole('swapper')">
                                <span>Swapper</span>
                            </label>
                            <span class="role-desc">Swap votes between players</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-noise_maker" onchange="toggleAdvancedRole('noise_maker')">
                                <span>Noise Maker</span>
                            </label>
                            <span class="role-desc">Choose who finds you</span>
                        </div>
                    </div>

                    <!-- Impostor Variants -->
                    <div class="role-category">
                        <h5 class="category-impostor">Impostor Variants</h5>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-evil_guesser" onchange="toggleAdvancedRole('evil_guesser')">
                                <span>Riddler</span>
                            </label>
                            <span class="role-desc">Guess roles (risky!)</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-bounty_hunter" onchange="toggleAdvancedRole('bounty_hunter')">
                                <span>Rampager</span>
                            </label>
                            <span class="role-desc">Faster kills on target</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-cleaner" onchange="toggleAdvancedRole('cleaner')">
                                <span>Cleaner</span>
                            </label>
                            <span class="role-desc">Move bodies elsewhere</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-venter" onchange="toggleAdvancedRole('venter')">
                                <span>Venter</span>
                            </label>
                            <span class="role-desc">Can go outside/through vents</span>
                        </div>
                    </div>

                    <!-- Neutral Roles -->
                    <div class="role-category">
                        <h5 class="category-neutral">Neutral Roles</h5>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="toggle-jester" onchange="toggleRole('jester')">
                                <span>Jester</span>
                            </label>
                            <span class="role-desc">Get voted out to win</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="toggle-lonewolf" onchange="toggleRole('lonewolf')">
                                <span>Lone Wolf</span>
                            </label>
                            <span class="role-desc">Kill everyone to win</span>
                        </div>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="role-vulture" onchange="toggleAdvancedRole('vulture')">
                                <span>Vulture</span>
                            </label>
                            <span class="role-desc">Eat bodies to win</span>
                            <div class="role-sub-setting" id="vulture-eat-setting" style="display: none;">
                                <span>Bodies needed:</span>
                                <button class="btn btn-tiny" onclick="adjustSetting('vulture_eat_count', -1)">-</button>
                                <span id="vulture-eat-count-display">3</span>
                                <button class="btn btn-tiny" onclick="adjustSetting('vulture_eat_count', 1)">+</button>
                            </div>
                        </div>
                    </div>

                    <!-- Special Roles -->
                    <div class="role-category">
                        <h5 class="category-special">Special Roles</h5>
                        <div class="role-config-item">
                            <label class="toggle">
                                <input type="checkbox" id="toggle-minion" onchange="toggleRole('minion')">
                                <span>Minion</span>
                            </label>
                            <span class="role-desc">Wins with impostors (blind)</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Per-Character Cooldown Settings -->
            <div id="cooldown-settings" class="cooldown-settings" style="display: none;">
                <!-- Impostor Cooldown -->
                <div class="cooldown-row" id="impostor-cooldown-row">
                    <span class="role-impostor">Impostor Kill</span>
                    <div class="number-control">
                        <button class="btn-small" onclick="adjustSetting('impostor_cooldown', -5)">-</button>
                        <span class="timer-value"><span id="setting-impostor-cooldown">45</span>s</span>
                        <button class="btn-small" onclick="adjustSetting('impostor_cooldown', 5)">+</button>
                    </div>
                </div>
                <!-- Sheriff Cooldown -->
                <div class="cooldown-row" id="sheriff-cooldown-row" style="display: none;">
                    <span class="role-sheriff">Sheriff Shoot</span>
                    <div class="number-control">
                        <button class="btn-small" onclick="adjustSetting('sheriff_cooldown', -5)">-</button>
                        <span class="timer-value"><span id="setting-sheriff-cooldown">45</span>s</span>
                        <button class="btn-small" onclick="adjustSetting('sheriff_cooldown', 5)">+</button>
                    </div>
                </div>
                <!-- Lone Wolf Cooldown -->
                <div class="cooldown-row" id="lonewolf-cooldown-row" style="display: none;">
                    <span class="role-lone-wolf">Lone Wolf Kill</span>
                    <div class="number-control">
                        <button class="btn-small" onclick="adjustSetting('lonewolf_cooldown', -5)">-</button>
                        <span class="timer-value"><span id="setting-lonewolf-cooldown">45</span>s</span>
                        <button class="btn-small" onclick="adjustSetting('lonewolf_cooldown', 5)">+</button>
                    </div>
                </div>
            </div>

            <!-- Sabotage Settings -->
            <div class="sabotage-settings">
                <div class="section-header" onclick="toggleSabotageSettings()">
                    <h4>Sabotage</h4>
                    <span id="sabotage-toggle-icon">-</span>
                </div>
                <div id="sabotage-settings-content" style="display: block;">
                    <label class="toggle">
                        <input type="checkbox" id="toggle-sabotage" onchange="toggleSabotageSetting()">
                        <span>Enable Sabotage</span>
                    </label>
                    <div id="sabotage-config" style="display: none;">
                        <div class="setting">
                            <label>Sabotage Cooldown</label>
                            <div class="number-control">
                                <button class="btn-small" onclick="adjustSetting('sabotage_cooldown', -5)">-</button>
                                <span class="timer-value"><span id="setting-sabotage-cooldown">90</span>s</span>
                                <button class="btn-small" onclick="adjustSetting('sabotage_cooldown', 5)">+</button>
                            </div>
                        </div>
                        <div class="sabotage-list">
                            <!-- Sabotage 1: Lights -->
                            <div class="sabotage-item">
                                <label class="toggle">
                                    <input type="checkbox" id="toggle-sab-1" checked onchange="toggleSabotageItem(1)">
                                    <span id="sab-1-name">Lights</span>
                                </label>
                                <span class="sab-type">(no timer)</span>
                            </div>
                            <!-- Sabotage 2: Reactor -->
                            <div class="sabotage-item">
                                <label class="toggle">
                                    <input type="checkbox" id="toggle-sab-2" checked onchange="toggleSabotageItem(2)">
                                    <span id="sab-2-name">Reactor</span>
                                </label>
                                <div class="number-control">
                                    <button class="btn-small" onclick="adjustSabotageTimer(2, -5)">-</button>
                                    <span class="timer-value"><span id="sab-2-timer">45</span>s</span>
                                    <button class="btn-small" onclick="adjustSabotageTimer(2, 5)">+</button>
                                </div>
                            </div>
                            <!-- Sabotage 3: O2 -->
                            <div class="sabotage-item">
                                <label class="toggle">
                                    <input type="checkbox" id="toggle-sab-3" checked onchange="toggleSabotageItem(3)">
                                    <span id="sab-3-name">O2</span>
                                </label>
                                <div class="number-control">
                                    <button class="btn-small" onclick="adjustSabotageTimer(3, -5)">-</button>
                                    <span class="timer-value"><span id="sab-3-timer">45</span>s</span>
                                    <button class="btn-small" onclick="adjustSabotageTimer(3, 5)">+</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Meeting & Voting Settings -->
            <div class="meeting-voting-settings">
                <div class="section-header" onclick="toggleMeetingSettings()">
                    <h4>Meetings & Voting</h4>
                    <span id="meeting-toggle-icon">+</span>
                </div>
                <div id="meeting-settings-content" style="display: none;">
                    <label class="toggle">
                        <input type="checkbox" id="toggle-voting" onchange="toggleVotingSetting()">
                        <span>Enable In-App Voting</span>
                    </label>
                    <div id="voting-config" style="display: none;">
                        <label class="toggle">
                            <input type="checkbox" id="toggle-anonymous" onchange="toggleAnonymousVoting()">
                            <span>Anonymous Voting</span>
                        </label>
                        <div class="setting">
                            <label>Meeting Timer</label>
                            <div class="number-control">
                                <button class="btn-small" onclick="adjustSetting('meeting_timer', -10)">-</button>
                                <span class="timer-value"><span id="setting-meeting-timer">120</span>s</span>
                                <button class="btn-small" onclick="adjustSetting('meeting_timer', 10)">+</button>
                            </div>
                        </div>
                        <div class="setting">
                            <label>Warning Sound At</label>
                            <div class="number-control">
                                <button class="btn-small" onclick="adjustSetting('meeting_warning', -5)">-</button>
                                <span class="timer-value"><span id="setting-meeting-warning">30</span>s</span>
                                <button class="btn-small" onclick="adjustSetting('meeting_warning', 5)">+</button>
                            </div>
                        </div>
                        <div class="setting">
                            <label>Discussion Time</label>
                            <div class="number-control">
                                <button class="btn-small" onclick="adjustSetting('discussion_time', -5)">-</button>
                                <span class="timer-value"><span id="setting-discussion-time">5</span>s</span>
                                <button class="btn-small" onclick="adjustSetting('discussion_time', 5)">+</button>
                            </div>
                        </div>
                        <div class="setting">
                            <label>Results Display Time</label>
                            <div class="number-control">
                                <button class="btn-small" onclick="adjustSetting('vote_results_duration', -5)">-</button>
                                <span class="timer-value"><span id="setting-vote-results-duration">10</span>s</span>
                                <button class="btn-small" onclick="adjustSetting('vote_results_duration', 5)">+</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Task Management -->
            <div class="task-management">
                <div class="section-header" onclick="toggleTaskList()">
                    <h4>Manage Tasks</h4>
                    <span id="task-toggle-icon">+</span>
                </div>
                <div id="task-management-content" class="collapsible-content" style="display: none;">
                    <div class="add-task-form">
                        <input type="text" id="new-task-input" placeholder="New task name" maxlength="30">
                        <button class="btn-small" onclick="addTask()">Add</button>
                    </div>
                    <div id="available-tasks-list" class="available-tasks-list"></div>
                </div>
            </div>

            <button class="btn btn-primary btn-large" id="start-game-btn" onclick="startGame()">
                START GAME
            </button>
        </div>

        <!-- Rules and Leave Buttons (visible to all) -->
        <div class="lobby-actions">
            <button class="btn btn-secondary" onclick="showRules()">
                How to Play
            </button>
            <button class="btn btn-danger-outline" onclick="leaveGame()">
                Leave Game
            </button>
        </div>

        <div id="waiting-message" class="waiting-message">
            Waiting for host to start...
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="screen" style="display: none;">
        <!-- Sabotage Alert Banner (above tasks, pushes content down) -->
        <div id="sabotage-alert" class="sabotage-alert" style="display: none;">
            <div class="sabotage-alert-content">
                <div class="sabotage-name" id="active-sabotage-name">LIGHTS OUT!</div>
                <div class="sabotage-timer" id="active-sabotage-timer" style="display: none;">
                    <span id="sabotage-remaining">45</span>s
                </div>
                <div class="sabotage-fix-info" id="sabotage-fix-info"></div>
                <button class="btn btn-success" id="fix-sabotage-btn" onclick="fixSabotage()">FIX</button>
                <button class="btn btn-success" id="hold-sabotage-btn" style="display: none;"
                    onmousedown="holdReactorStart()" onmouseup="holdReactorEnd()"
                    ontouchstart="holdReactorStart()" ontouchend="holdReactorEnd()">
                    HOLD TO FIX
                </button>
            </div>
        </div>

        <!-- Tasks at top (visible immediately) -->
        <div class="tasks-section">
            <h3>Your Tasks</h3>
            <div id="task-list" class="task-list"></div>
        </div>

        <div class="action-buttons">
            <button class="btn btn-danger btn-large" id="report-body-btn" onclick="reportBody()">
                REPORT BODY
            </button>
            <button class="btn btn-warning-outline" id="call-meeting-btn" onclick="callMeeting()">
                CALL MEETING
            </button>
            <button class="btn btn-secondary" id="im-dead-btn" onclick="markDead()">
                I'M DEAD
            </button>
            <button class="btn btn-secondary" id="map-btn" onclick="showMapGallery()">
                MAP
            </button>
            <button class="btn btn-secondary" id="roles-btn" onclick="showRoleGuide()">
                ROLES
            </button>
        </div>

        <!-- Scroll hint right below buttons -->
        <div class="scroll-hint">
            <span class="scroll-arrow">↓</span>
            <span class="scroll-text">Scroll down to see your role</span>
            <span class="scroll-arrow">↓</span>
        </div>

        <!-- Scroll spacer to hide role below the fold -->
        <div class="scroll-spacer"></div>

        <!-- Role info below the fold (scroll down to see) -->
        <div class="role-info-section">
            <!-- Compact role indicator -->
            <div class="role-badge" id="role-badge">
                <span class="role-name-small" id="role-name-badge">CREWMATE</span>
            </div>

            <div class="role-display" id="role-display">
                <span class="role-team" id="role-team">CREWMATE</span>
                <span class="role-label">You are</span>
                <span class="role-name" id="role-name">CREWMATE</span>
                <p class="role-description" id="role-description"></p>
            </div>

            <!-- Role ability buttons - below role card, only visible for specific roles -->
            <button class="btn btn-jester btn-large" id="jester-voted-btn" onclick="jesterVotedOut()" style="display: none;">
                I WAS VOTED OUT!
            </button>

            <!-- Engineer: Fix sabotage remotely (one use) -->
            <button class="btn btn-ability btn-engineer-fix btn-large" id="engineer-fix-btn" onclick="engineerFix()" style="display: none;">
                FIX SABOTAGE REMOTELY
            </button>

            <!-- Captain: Remote meeting from anywhere (one use) -->
            <button class="btn btn-ability btn-captain-meeting btn-large" id="captain-meeting-btn" onclick="captainMeeting()" style="display: none;">
                REMOTE MEETING
            </button>

            <!-- Vulture: Eat body -->
            <div id="vulture-eat-section" class="ability-section" style="display: none;">
                <div class="vulture-progress">
                    <span id="vulture-count">0</span> / <span id="vulture-needed">3</span> bodies eaten
                </div>
                <div id="vulture-body-list" class="vulture-body-list">
                    <!-- Populated with dead players -->
                </div>
            </div>

            <!-- Rampager: Target display and "Was it you?" flow -->
            <div id="bounty-hunter-section" class="ability-section" style="display: none;">
                <div class="bounty-target-display" style="background: rgba(185,28,28,0.2); border: 1px solid #b91c1c; border-radius: 8px; padding: 10px; margin-bottom: 8px; text-align: center;">
                    <span style="color: #94a3b8; font-size: 12px;">TARGET</span>
                    <div id="bounty-target-name" style="color: #ef4444; font-size: 20px; font-weight: bold;"></div>
                    <div id="bounty-kills-display" style="color: #94a3b8; font-size: 12px; margin-top: 4px;"></div>
                </div>
                <div id="bounty-was-it-you" style="display: none; text-align: center; margin-top: 8px;">
                    <div id="bounty-prompt-text" style="color: #fbbf24; font-size: 14px; font-weight: bold; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-large" onclick="bountyKillClaim(true)" style="flex: 1; background: #22c55e; color: white;">YES</button>
                        <button class="btn btn-large" onclick="bountyKillClaim(false)" style="flex: 1; background: #6b7280; color: white;">NO</button>
                    </div>
                </div>
            </div>

            <div id="fellow-impostors" class="fellow-impostors" style="display: none;">
                <span class="label">Fellow Impostors:</span>
                <span id="impostor-names"></span>
            </div>

            <!-- Sabotage Section (Impostor only) -->
            <div id="impostor-sabotage-section" class="sabotage-section" style="display: none;">
                <h3>Sabotage</h3>
                <div id="impostor-sabotage-buttons" class="sabotage-buttons">
                    <!-- Dynamically populated -->
                </div>
                <div id="impostor-sabotage-cooldown" class="sabotage-cooldown" style="display: none;">
                    Cooldown: <span id="impostor-sabotage-cooldown-time">0</span>s
                </div>
            </div>

            <!-- Kill Cooldown Timer (for impostor/sheriff) -->
            <div id="cooldown-timer" class="cooldown-timer" style="display: none;">
                <div class="cooldown-display">
                    <span id="cooldown-text">Kill Ready</span>
                    <button class="btn btn-small start-cooldown-btn" id="start-cooldown-btn" onclick="startCooldown()">Start Timer</button>
                </div>
            </div>

            <!-- Task Progress (hidden between meetings) -->
            <div class="task-progress" id="game-task-progress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <span class="progress-text" id="progress-text">0% Tasks Complete</span>
            </div>
        </div>
    </div>

    <!-- Meeting Screen -->
    <div id="meeting-screen" class="screen" style="display: none;">
        <div class="meeting-header" id="meeting-header">
            <h1 id="meeting-title">MEETING</h1>
            <p id="meeting-caller"></p>
        </div>
        <button class="btn btn-secondary btn-small-inline" onclick="showRoleGuide()" style="margin: 4px 0 4px 12px; font-size: 11px; padding: 3px 10px; opacity: 0.7;">Role Guide</button>

        <!-- Gathering Phase (waiting for caller to start meeting) -->
        <div id="gathering-section" style="display: none;">
            <div id="gathering-message" class="gathering-message">
                Waiting for meeting to start...
            </div>
            <button class="btn btn-primary btn-large" id="start-meeting-btn" onclick="startVotingPhase()" style="display: none;">
                START MEETING
            </button>
        </div>

        <!-- Meeting Timer -->
        <div class="meeting-timer" id="meeting-timer" style="display: none;">
            <div class="timer-circle">
                <span id="meeting-timer-display">2:00</span>
            </div>
        </div>

        <div class="task-progress">
            <div class="progress-bar">
                <div class="progress-fill" id="meeting-progress-fill" style="width: 0%"></div>
            </div>
            <span class="progress-text" id="meeting-progress-text">0% Tasks Complete</span>
        </div>

        <!-- Voting Section -->
        <div class="voting-section" id="voting-section" style="display: none;">
            <h3>Vote to Eliminate</h3>
            <div id="vote-options" class="vote-options">
                <!-- Populated with alive players as vote buttons -->
            </div>
            <button class="btn btn-secondary btn-large" id="skip-vote-btn" onclick="castVote(null)">
                SKIP VOTE
            </button>
            <div class="vote-status" id="vote-status">
                <span id="votes-cast-count">0</span> / <span id="votes-needed-count">0</span> voted
            </div>
            <!-- Vote feed for non-anonymous voting -->
            <div class="vote-feed" id="vote-feed" style="display: none;">
                <!-- Shows "Player voted for Target" entries -->
            </div>
            <!-- Swapper UI -->
            <div id="swapper-section" style="display: none; margin-top: 15px; padding: 10px; background: rgba(236,72,153,0.1); border: 1px solid #ec4899; border-radius: 8px;">
                <h4 style="color: #ec4899; margin: 0 0 8px 0; font-size: 14px;">SWAP VOTES</h4>
                <div id="swapper-controls">
                    <button class="btn btn-secondary" id="swap-player1-btn" onclick="openSwapSelect(1)" style="width: 100%; margin-bottom: 6px; font-size: 13px;">[Select Player 1]</button>
                    <span style="color: #94a3b8; display: block; text-align: center; font-size: 12px;">&#8593; swap with &#8595;</span>
                    <button class="btn btn-secondary" id="swap-player2-btn" onclick="openSwapSelect(2)" style="width: 100%; margin-top: 6px; margin-bottom: 8px; font-size: 13px;">[Select Player 2]</button>
                    <button class="btn btn-primary" id="confirm-swap-btn" onclick="confirmSwap()" disabled style="width: 100%; font-size: 13px;">CONFIRM SWAP</button>
                </div>
                <div id="swapper-result" style="display: none; color: #ec4899; text-align: center; font-size: 14px; padding: 8px;"></div>
            </div>
            <!-- Swap Player Select Modal -->
            <div id="swap-select-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1001; justify-content: center; align-items: center;">
                <div style="background: #1e293b; border-radius: 12px; padding: 15px; max-width: 300px; width: 90%;">
                    <h4 style="color: #ec4899; margin: 0 0 10px 0;">Select Player</h4>
                    <div id="swap-select-options"></div>
                    <button class="btn btn-secondary" onclick="closeSwapSelect()" style="width: 100%; margin-top: 8px;">Cancel</button>
                </div>
            </div>
            <!-- Guesser Role Select Modal -->
            <div id="guesser-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 1002; justify-content: center; align-items: center;">
                <div style="background: #1e293b; border-radius: 12px; padding: 15px; max-width: 320px; width: 90%; max-height: 70vh; overflow-y: auto;">
                    <h4 style="color: #14b8a6; margin: 0 0 5px 0;">Guess Role</h4>
                    <p id="guesser-target-label" style="color: #94a3b8; font-size: 13px; margin: 0 0 10px 0;"></p>
                    <div id="guesser-role-options"></div>
                    <button class="btn btn-secondary" onclick="closeGuesserModal()" style="width: 100%; margin-top: 8px;">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Vote Results Section -->
        <div class="vote-results" id="vote-results-section" style="display: none;">
            <h3>Vote Results</h3>
            <div id="vote-results-list"></div>
            <div id="vote-outcome"></div>
            <div id="vote-results-countdown" style="color: #94a3b8; margin-top: 10px; font-size: 14px;"></div>
        </div>

        <!-- Players Lists (shown when voting disabled) -->
        <div class="meeting-players" id="meeting-players-section">
            <div class="alive-section">
                <h3>Alive</h3>
                <div id="alive-list" class="player-list"></div>
            </div>
            <div class="dead-section">
                <h3>Dead</h3>
                <div id="dead-list" class="player-list"></div>
            </div>
        </div>

        <button class="btn btn-secondary btn-large" id="end-meeting-btn" onclick="endMeeting()">
            END MEETING
        </button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameover-screen" class="screen" style="display: none;">
        <div class="gameover-header">
            <h1 id="winner-text">CREWMATES WIN!</h1>
        </div>

        <div class="roles-reveal">
            <h3>Roles</h3>
            <div id="roles-list" class="roles-list"></div>
        </div>

        <button class="btn btn-primary btn-large" onclick="returnToLobby()">
            PLAY AGAIN
        </button>
    </div>

    <div class="error-message" id="error-message"></div>

    <!-- Rules Modal -->
    <div id="rules-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>How to Play</h2>
                <button class="modal-close" onclick="hideRules()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="rule-section">
                    <h3 class="role-crewmate">Crewmate</h3>
                    <p>Complete all your tasks OR vote out all impostors to win. Work together to find who's lying!</p>
                </div>
                <div class="rule-section">
                    <h3 class="role-impostor">Impostor</h3>
                    <p>Eliminate crewmates until impostors equal or outnumber them. Blend in, fake tasks, and don't get caught!</p>
                </div>
                <div class="rule-section" id="rule-jester" style="display: none;">
                    <h3 class="role-jester">Jester</h3>
                    <p>Get yourself voted out during a meeting to win! Act suspicious, but not TOO suspicious...</p>
                </div>
                <div class="rule-section" id="rule-lonewolf" style="display: none;">
                    <h3 class="role-lone-wolf">Lone Wolf</h3>
                    <p>Be one of the last 2 players alive with no impostors remaining. You're on your own!</p>
                </div>
                <div class="rule-section" id="rule-minion" style="display: none;">
                    <h3 class="role-minion">Minion</h3>
                    <p>Help the impostors win! You know who they are, but you cannot kill. Misdirect the crew!</p>
                </div>
                <div class="rule-section" id="rule-sheriff" style="display: none;">
                    <h3 class="role-sheriff">Sheriff</h3>
                    <p>You have tasks like a crewmate, but you can also shoot! Whisper to a player that you're shooting them. If they're an impostor, they die. If they're innocent, YOU die! (Trust-based)</p>
                </div>
                <div class="rule-section">
                    <h3>Gameplay</h3>
                    <ul>
                        <li><strong>Tasks:</strong> Physical tasks around the venue. Tap to mark complete.</li>
                        <li><strong>Meetings:</strong> Anyone can call a meeting to discuss. Vote verbally in person!</li>
                        <li><strong>Death:</strong> If eliminated, tap "I'm Dead" to update the game.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Map Gallery Modal -->
    <div id="map-modal" class="modal" style="display: none;">
        <div class="modal-content map-modal-content">
            <div class="modal-header">
                <h2>Map</h2>
                <button class="modal-close" onclick="hideMapGallery()">&times;</button>
            </div>
            <div class="map-gallery">
                <div class="map-swiper" id="map-swiper">
                    <div class="map-slide active" data-index="0">
                        <img src="/static/images/maps/downstairs1.png" alt="Downstairs 1" class="zoomable-map">
                        <div class="map-label">Downstairs 1</div>
                    </div>
                    <div class="map-slide" data-index="1">
                        <img src="/static/images/maps/downstairs2.png" alt="Downstairs 2" class="zoomable-map">
                        <div class="map-label">Downstairs 2</div>
                    </div>
                    <div class="map-slide" data-index="2">
                        <img src="/static/images/maps/upstairs1.png" alt="Upstairs 1" class="zoomable-map">
                        <div class="map-label">Upstairs 1</div>
                    </div>
                    <div class="map-slide" data-index="3">
                        <img src="/static/images/maps/upstairs2.png" alt="Upstairs 2" class="zoomable-map">
                        <div class="map-label">Upstairs 2</div>
                    </div>
                </div>
                <div class="map-indicators">
                    <span class="map-indicator active" data-index="0" onclick="goToMapSlide(0)"></span>
                    <span class="map-indicator" data-index="1" onclick="goToMapSlide(1)"></span>
                    <span class="map-indicator" data-index="2" onclick="goToMapSlide(2)"></span>
                    <span class="map-indicator" data-index="3" onclick="goToMapSlide(3)"></span>
                </div>
                <div class="map-nav">
                    <button class="map-nav-btn" onclick="prevMapSlide()">&#8249;</button>
                    <button class="map-nav-btn" onclick="nextMapSlide()">&#8250;</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Noise Maker Selection Modal -->
<div id="noise-maker-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 350px;">
        <div class="modal-header">
            <h2 style="color: #f59e0b;">Select Who Killed You</h2>
        </div>
        <p style="color: #94a3b8; font-size: 13px; margin-bottom: 10px;">They will "find" your body and trigger a meeting.</p>
        <div id="noise-maker-player-list" style="max-height: 50vh; overflow-y: auto;">
            <!-- Populated with alive players -->
        </div>
    </div>
</div>

<style>
.role-guide-desc.expanded {
    max-height: 100px !important;
    margin-top: 6px !important;
}
</style>
<!-- Role Guide Modal -->
<div id="role-guide-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
        <div class="modal-header">
            <h2>Role Guide</h2>
            <button class="modal-close" onclick="hideRoleGuide()">&times;</button>
        </div>
        <div id="role-guide-content" style="padding: 10px;">
            <p style="color: #94a3b8;">Loading...</p>
        </div>
    </div>
</div>

<!-- Game sounds -->
<audio id="sound-game-start" preload="auto">
    <source src="/static/sounds/Start_of_game_role_reveal.mp3" type="audio/mpeg">
</audio>
<audio id="sound-meeting" preload="auto">
    <source src="/static/sounds/Meeting_or_body.mp3" type="audio/mpeg">
</audio>

<!-- Win condition sounds -->
<audio id="sound-crewmate-win" preload="auto">
    <source src="/static/sounds/Wincon Sounds/Crewmates_win.mp3" type="audio/mpeg">
</audio>
<audio id="sound-impostor-win" preload="auto">
    <source src="/static/sounds/Wincon Sounds/Imposters_win.mp3" type="audio/mpeg">
</audio>
<audio id="sound-jester-win" preload="auto">
    <source src="/static/sounds/Wincon Sounds/Jester_win.mp3" type="audio/mpeg">
</audio>
<audio id="sound-lonewolf-win" preload="auto">
    <source src="/static/sounds/Wincon Sounds/Lone_wolf_win.mp3" type="audio/mpeg">
</audio>
<audio id="sound-vulture-win" preload="auto">
    <source src="/static/sounds/Wincon Sounds/Vulture_win.mp3" type="audio/mpeg">
</audio>

<!-- Voting sounds -->
<audio id="sound-voting-warning" preload="auto">
    <source src="/static/sounds/Voting/Voting_warning.mp3" type="audio/mpeg">
</audio>
<audio id="sound-time-to-vote" preload="auto">
    <source src="/static/sounds/Voting/Time_to_vote.mp3" type="audio/mpeg">
</audio>

<!-- Sabotage sounds -->
<audio id="sound-lights-sabotage" preload="auto">
    <source src="/static/sounds/Sabotage/lights_sabotaged.mp3" type="audio/mpeg">
</audio>
<audio id="sound-lights-fixed" preload="auto">
    <source src="/static/sounds/Sabotage/lights_on.mp3" type="audio/mpeg">
</audio>
<audio id="sound-reactor-sabotage" preload="auto">
    <source src="/static/sounds/Sabotage/Reactor_Oxygen_sabotaged.mp3" type="audio/mpeg">
</audio>
<audio id="sound-reactor-fixed" preload="auto">
    <source src="/static/sounds/Sabotage/Reactor_Oxygen_on.mp3" type="audio/mpeg">
</audio>
<audio id="sound-death-meeting" preload="auto">
    <source src="/static/sounds/Death_during_meeting.mp3" type="audio/mpeg">
</audio>

<script>
const gameCode = '{{ code }}';
const sessionToken = localStorage.getItem('session_token');
const playerId = localStorage.getItem('player_id');

// === Role Constants (single source of truth) ===
const IMPOSTOR_SABOTAGE_ROLES = ['Impostor', 'Riddler', 'Rampager', 'Cleaner', 'Venter'];
const REAL_TASK_ROLES = ['Crewmate', 'Sheriff', 'Engineer', 'Captain', 'Mayor', 'Bounty Hunter', 'Spy', 'Swapper', 'Noise Maker'];
const GUESSER_ROLES = ['Bounty Hunter', 'Riddler'];
const IMPOSTOR_SUBTYPES = ['Rampager', 'Riddler', 'Cleaner', 'Venter', 'Minion'];
const KILL_COOLDOWN_ROLES = ['Impostor', 'Rampager', 'Sheriff', 'Lone Wolf'];

let ws = null;
let gameState = 'lobby';
let isHost = false;
let myRole = null;
let hasUsedMeeting = false;  // Track if player used their one emergency meeting
let settings = { tasks_per_player: 5, num_impostors: 2, enable_jester: false, enable_lone_wolf: false, enable_minion: false, enable_sheriff: false, kill_cooldown: 45, impostor_kill_cooldown: 45, sheriff_shoot_cooldown: 45, lone_wolf_kill_cooldown: 45, enable_sabotage: false, sabotage_cooldown: 90, meeting_cooldown: 30, enable_voting: true, anonymous_voting: false, meeting_timer_duration: 120, meeting_warning_time: 30, discussion_time: 5, vote_results_duration: 10, role_configs: {} };
let killCooldownTimer = null;
let cooldownEndTime = null;
let bountyKills = 0;
let bountyTargetId = null;
let availableTasks = [];
let allPlayers = [];

// Meeting state - consolidated into single object for clean state management
let meetingState = {
    phase: null,           // null, 'gathering', 'voting', 'results'
    callerId: null,
    callerName: null,
    meetingType: null,     // 'meeting' or 'body_report'
    hasVoted: false,
    warningPlayed: false,
    votingEnabled: false,
    payload: null,         // Full payload for reference
    discussionEndsAt: null,
    votingEndsAt: null
};

// Timer intervals (kept separate for easy cleanup)
let meetingTimerInterval = null;
let discussionTimerInterval = null;
let voteResultsTimerInterval = null;

function resetMeetingState() {
    meetingState = {
        phase: null,
        callerId: null,
        callerName: null,
        meetingType: null,
        hasVoted: false,
        warningPlayed: false,
        votingEnabled: false,
        payload: null,
        discussionEndsAt: null,
        votingEndsAt: null
    };
    // Clear all meeting-related timers
    if (meetingTimerInterval) {
        clearInterval(meetingTimerInterval);
        meetingTimerInterval = null;
    }
    if (discussionTimerInterval) {
        clearInterval(discussionTimerInterval);
        discussionTimerInterval = null;
    }
    if (voteResultsTimerInterval) {
        clearInterval(voteResultsTimerInterval);
        voteResultsTimerInterval = null;
    }
}

function renderMeetingPhase() {
    // Central function to render UI based on meeting phase
    const gathering = document.getElementById('gathering-section');
    const voting = document.getElementById('voting-section');
    const results = document.getElementById('vote-results-section');
    const timer = document.getElementById('meeting-timer');
    const endBtn = document.getElementById('end-meeting-btn');
    const playersSection = document.getElementById('meeting-players-section');

    // Hide all meeting sections first
    gathering.style.display = 'none';
    voting.style.display = 'none';
    results.style.display = 'none';
    timer.style.display = 'none';
    endBtn.style.display = 'none';
    playersSection.style.display = 'none';

    if (!meetingState.votingEnabled) {
        // Voting disabled - just show player lists
        playersSection.style.display = 'block';
        return;
    }

    switch (meetingState.phase) {
        case 'gathering':
            gathering.style.display = 'block';
            // Show START MEETING only for caller
            const isCaller = playerId === meetingState.callerId;
            const startBtn = document.getElementById('start-meeting-btn');
            if (isCaller) {
                startBtn.style.display = 'block';
                startBtn.textContent = 'START MEETING';
                // Disable briefly to prevent ghost clicks from screen transition
                startBtn.disabled = true;
                setTimeout(() => {
                    startBtn.disabled = false;
                }, 1200);
            } else {
                startBtn.style.display = 'none';
            }
            document.getElementById('gathering-message').style.display = isCaller ? 'none' : 'block';
            break;

        case 'voting':
            voting.style.display = 'block';
            timer.style.display = 'block';
            // END MEETING hidden during voting - only show after results
            break;

        case 'results':
            results.style.display = 'block';
            // END MEETING button hidden initially - shown after vote_results_duration countdown
            // (handleVoteResults starts the countdown)
            break;
    }
}

function restoreMeetingState(activeMeeting) {
    // Restore meeting state after reconnection
    resetMeetingState();

    meetingState.phase = activeMeeting.phase;
    meetingState.callerId = activeMeeting.caller_id;
    meetingState.callerName = activeMeeting.caller_name;
    meetingState.meetingType = activeMeeting.meeting_type;
    meetingState.hasVoted = activeMeeting.has_voted;
    meetingState.votingEnabled = true;  // If we're in meeting, voting is enabled
    meetingState.payload = {
        alive_players: activeMeeting.alive_players,
        dead_players: activeMeeting.dead_players
    };

    // Setup meeting header
    const meetingHeader = document.getElementById('meeting-header');
    const meetingTitle = document.getElementById('meeting-title');
    const meetingCaller = document.getElementById('meeting-caller');

    if (activeMeeting.meeting_type === 'body_report') {
        meetingHeader.classList.add('body-report');
        meetingTitle.textContent = 'DEAD BODY REPORTED';
    } else {
        meetingHeader.classList.remove('body-report');
        meetingTitle.textContent = 'EMERGENCY MEETING';
    }

    // Show caller name if past gathering phase
    if (activeMeeting.phase !== 'gathering') {
        meetingCaller.textContent = activeMeeting.meeting_type === 'body_report'
            ? `Reported by ${activeMeeting.caller_name}`
            : `Called by ${activeMeeting.caller_name}`;
    } else {
        meetingCaller.textContent = '';
    }

    // Populate player lists
    document.getElementById('alive-list').innerHTML = activeMeeting.alive_players.map(p => `
        <div class="player-item">${p.name}</div>
    `).join('');

    document.getElementById('dead-list').innerHTML = activeMeeting.dead_players.map(p => `
        <div class="player-item dead">${p.name}</div>
    `).join('');

    // Reset vote feed
    const voteFeed = document.getElementById('vote-feed');
    voteFeed.innerHTML = '';
    voteFeed.style.display = 'none';

    // Setup phase-specific UI
    if (activeMeeting.phase === 'voting') {
        // Restore voting UI
        const votingSection = document.getElementById('voting-section');
        const voteOptions = document.getElementById('vote-options');
        const skipBtn = document.getElementById('skip-vote-btn');

        const me = allPlayers.find(p => p.id === playerId);
        const amAlive = me && me.status !== 'dead';
        const inDeadList = activeMeeting.dead_players.some(p => p.id === playerId);
        const canVote = amAlive && !inDeadList;

        if (canVote && !activeMeeting.has_voted) {
            voteOptions.innerHTML = activeMeeting.alive_players
                .map(p => `
                    <button class="btn vote-btn" onclick="castVote('${p.id}')">
                        ${p.name}
                    </button>
                `).join('');
            skipBtn.style.display = 'block';
            skipBtn.disabled = false;
        } else if (activeMeeting.has_voted) {
            voteOptions.innerHTML = '<div class="dead-voter-message">You have already voted.</div>';
            skipBtn.style.display = 'none';
        } else {
            voteOptions.innerHTML = '<div class="dead-voter-message">You are dead. You cannot vote.</div>';
            skipBtn.style.display = 'none';
        }

        // Update vote counts
        document.getElementById('votes-cast-count').textContent = activeMeeting.votes_cast;
        document.getElementById('votes-needed-count').textContent = activeMeeting.votes_needed;

        // Start timer from remaining time
        if (activeMeeting.voting_remaining > 0) {
            meetingEndTime = Date.now() + (activeMeeting.voting_remaining * 1000);
            startMeetingTimer(activeMeeting.voting_remaining, settings.meeting_warning_time || 30);
        }
    } else if (activeMeeting.phase === 'results' && activeMeeting.result) {
        // Show results
        const resultsList = document.getElementById('vote-results-list');
        let resultsHtml = '';

        const sortedResults = Object.entries(activeMeeting.result.vote_counts || {})
            .sort((a, b) => b[1] - a[1]);

        for (const [name, count] of sortedResults) {
            const isEliminated = activeMeeting.result.eliminated_name === name;
            resultsHtml += `
                <div class="vote-result-item ${isEliminated ? 'eliminated' : ''}">
                    <span class="vote-result-name">${name}</span>
                    <span class="vote-result-count">${count} vote${count !== 1 ? 's' : ''}</span>
                </div>
            `;
        }

        if (activeMeeting.result.skip_count > 0) {
            resultsHtml += `
                <div class="vote-result-item skip">
                    <span class="vote-result-name">Skip</span>
                    <span class="vote-result-count">${activeMeeting.result.skip_count} vote${activeMeeting.result.skip_count !== 1 ? 's' : ''}</span>
                </div>
            `;
        }

        resultsList.innerHTML = resultsHtml;

        // Show outcome
        const outcomeEl = document.getElementById('vote-outcome');
        if (activeMeeting.result.outcome === 'eliminated') {
            outcomeEl.innerHTML = `<span class="eliminated-name">${activeMeeting.result.eliminated_name}</span> was ejected.`;
        } else if (activeMeeting.result.outcome === 'tie') {
            outcomeEl.textContent = 'Tie vote - no one was ejected.';
        } else {
            outcomeEl.textContent = 'No one was ejected.';
        }
        // On reconnect during results, show END MEETING immediately for everyone
        const endBtn = document.getElementById('end-meeting-btn');
        const countdownEl = document.getElementById('vote-results-countdown');
        endBtn.style.display = 'block';
        if (countdownEl) countdownEl.textContent = '';
    }

    // Render phase UI
    renderMeetingPhase();
    showScreen('meeting-screen');
}

// Legacy compatibility (will be removed after full refactor)
// These getters allow old code to work during transition
let meetingEndTime = null;

// Sound helper function
function playSound(soundId) {
    const sound = document.getElementById(soundId);
    if (sound) {
        sound.currentTime = 0;
        sound.play().catch(e => console.log('Sound play failed:', e));
    }
}

// Redirect if no session
if (!sessionToken) {
    window.location.href = '/';
}

// Connect WebSocket
function connectWS() {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws/${gameCode}/${sessionToken}`);

    ws.onopen = () => {
        console.log('WebSocket connected');
    };

    ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        handleMessage(msg);
    };

    ws.onclose = () => {
        console.log('WebSocket closed, reconnecting...');
        setTimeout(connectWS, 2000);
    };

    ws.onerror = (err) => {
        console.error('WebSocket error:', err);
    };
}

function handleMessage(msg) {
    console.log('Received:', msg);

    switch (msg.type) {
        case 'state_sync':
            handleStateSync(msg.payload);
            break;
        case 'player_joined':
        case 'player_connected':
        case 'player_disconnected':
        case 'player_left':
            refreshGame();
            break;
        case 'settings_changed':
            settings = msg.payload;
            updateSettingsUI();
            break;
        case 'tasks_updated':
            availableTasks = msg.payload.tasks;
            updateTasksUI();
            break;
        case 'game_started':
            handleGameStart(msg.payload);
            break;
        case 'task_completed':
            // Don't update progress bar in real-time - only visible during meetings
            break;
        case 'meeting_called':
            handleMeetingStart(msg.payload);
            break;
        case 'meeting_ended':
            handleMeetingEnd();
            break;
        case 'player_died':
            handlePlayerDeath(msg.payload);
            break;
        case 'game_ended':
            handleGameEnd(msg.payload);
            break;
        case 'sabotage_started':
            handleSabotageStarted(msg.payload);
            break;
        case 'sabotage_resolved':
            handleSabotageResolved(msg.payload);
            break;
        case 'sabotage_update':
            handleSabotageUpdate(msg.payload);
            break;
        case 'voting_started':
            handleVotingStarted(msg.payload);
            break;
        case 'vote_cast':
            handleVoteCast(msg.payload);
            break;
        case 'vote_results':
            handleVoteResults(msg.payload);
            break;
        case 'body_eaten':
            // Dead player notification that vulture ate their body
            if (msg.payload && msg.payload.message) {
                showError(msg.payload.message);
            }
            break;
        case 'guesser_result':
            handleGuesserResult(msg.payload);
            break;
        case 'bounty_target_update':
            if (myRole === 'Rampager' && msg.payload) {
                bountyTargetId = msg.payload.target_id;
                bountyKills = msg.payload.bounty_kills || bountyKills;
                document.getElementById('bounty-target-name').textContent = msg.payload.target_name || 'No target';
                updateBountyKillButton();
            }
            break;
    }
}

function handleStateSync(payload) {
    allPlayers = payload.players;
    updatePlayers(payload.players);
    updateProgress(payload.task_percentage);

    if (payload.role_info) {
        myRole = payload.role_info.role;
        updateRoleUI(payload.role_info);
    }

    if (payload.game_state === 'playing') {
        showScreen('game-screen');

        // Show sabotage UI for impostor-aligned roles
        if (IMPOSTOR_SABOTAGE_ROLES.includes(myRole) && settings.enable_sabotage) {
            showImpostorSabotageUI();
        }

        // Restore active sabotage state on reconnect
        if (payload.active_sabotage) {
            handleSabotageStarted(payload.active_sabotage);
            // Update fix progress for reactor/o2
            if (payload.active_sabotage.type === 'reactor') {
                document.getElementById('sabotage-fix-info').textContent =
                    `${payload.active_sabotage.reactor_holders}/2 people holding`;
            } else if (payload.active_sabotage.type === 'o2') {
                document.getElementById('sabotage-fix-info').textContent =
                    `${payload.active_sabotage.o2_switches}/2 switches`;
            }
        }
    } else if (payload.game_state === 'meeting') {
        // Restore meeting state on reconnect
        if (payload.active_meeting) {
            restoreMeetingState(payload.active_meeting);
        } else {
            showScreen('meeting-screen');
        }
    } else if (payload.game_state === 'ended') {
        showScreen('gameover-screen');
    }
}

function updatePlayers(players) {
    const list = document.getElementById('player-list');
    const count = document.getElementById('player-count');

    list.innerHTML = players.map(p => `
        <div class="player-item ${p.connected ? '' : 'disconnected'} ${p.is_host ? 'host' : ''}">
            <span class="player-name">${p.name}${p.is_host ? ' (Host)' : ''}</span>
            <span class="status-dot ${p.connected ? 'online' : 'offline'}"></span>
        </div>
    `).join('');

    count.textContent = `(${players.length})`;

    // Check if current player is host
    const me = players.find(p => p.id === playerId);
    if (me) {
        isHost = me.is_host;
        document.getElementById('host-controls').style.display = isHost ? 'block' : 'none';
        document.getElementById('waiting-message').style.display = isHost ? 'none' : 'block';
    }
}

function updateSettingsUI() {
    document.getElementById('setting-tasks').textContent = settings.tasks_per_player;
    document.getElementById('setting-impostors').textContent = settings.num_impostors;
    // Legacy roles now updated in updateAdvancedRolesUI
    // Per-character cooldowns
    document.getElementById('setting-impostor-cooldown').textContent = settings.impostor_kill_cooldown || settings.kill_cooldown;
    document.getElementById('setting-sheriff-cooldown').textContent = settings.sheriff_shoot_cooldown || settings.kill_cooldown;
    document.getElementById('setting-lonewolf-cooldown').textContent = settings.lone_wolf_kill_cooldown || settings.kill_cooldown;
    updateCooldownSettingsVisibility();
    updateSabotageSettingsUI();
    updateMeetingSettingsUI();
    updateAdvancedRolesUI();
}

function updateCooldownSettingsVisibility() {
    const cooldownSection = document.getElementById('cooldown-settings');
    const sheriffRow = document.getElementById('sheriff-cooldown-row');
    const lonewolfRow = document.getElementById('lonewolf-cooldown-row');

    // Always show cooldown settings (impostor always has one)
    cooldownSection.style.display = 'block';

    // Show Sheriff cooldown row only if Sheriff is enabled
    sheriffRow.style.display = settings.enable_sheriff ? 'flex' : 'none';

    // Show Lone Wolf cooldown row only if Lone Wolf is enabled
    lonewolfRow.style.display = settings.enable_lone_wolf ? 'flex' : 'none';
}

async function adjustSetting(type, delta) {
    let update = {};
    if (type === 'tasks') {
        const newVal = Math.max(1, Math.min(10, settings.tasks_per_player + delta));
        update.tasks_per_player = newVal;
    } else if (type === 'impostors') {
        const newVal = Math.max(1, Math.min(3, settings.num_impostors + delta));
        update.num_impostors = newVal;
    } else if (type === 'cooldown') {
        const newVal = Math.max(10, Math.min(120, settings.kill_cooldown + delta));
        update.kill_cooldown = newVal;
    } else if (type === 'impostor_cooldown') {
        const current = settings.impostor_kill_cooldown || settings.kill_cooldown;
        const newVal = Math.max(10, Math.min(120, current + delta));
        update.impostor_kill_cooldown = newVal;
    } else if (type === 'sheriff_cooldown') {
        const current = settings.sheriff_shoot_cooldown || settings.kill_cooldown;
        const newVal = Math.max(10, Math.min(120, current + delta));
        update.sheriff_shoot_cooldown = newVal;
    } else if (type === 'lonewolf_cooldown') {
        const current = settings.lone_wolf_kill_cooldown || settings.kill_cooldown;
        const newVal = Math.max(10, Math.min(120, current + delta));
        update.lone_wolf_kill_cooldown = newVal;
    } else if (type === 'sabotage_cooldown') {
        const current = settings.sabotage_cooldown || 90;
        const newVal = Math.max(10, Math.min(180, current + delta));
        update.sabotage_cooldown = newVal;
    } else if (type === 'meeting_timer') {
        const current = settings.meeting_timer_duration || 120;
        const newVal = Math.max(30, Math.min(300, current + delta));
        update.meeting_timer_duration = newVal;
    } else if (type === 'meeting_warning') {
        const current = settings.meeting_warning_time || 30;
        const maxWarning = settings.meeting_timer_duration || 120;
        const newVal = Math.max(0, Math.min(maxWarning, current + delta));
        update.meeting_warning_time = newVal;
    } else if (type === 'discussion_time') {
        const current = settings.discussion_time || 5;
        const newVal = Math.max(0, Math.min(60, current + delta));  // 0-60 seconds
        update.discussion_time = newVal;
    } else if (type === 'vote_results_duration') {
        const current = settings.vote_results_duration || 10;
        const newVal = Math.max(5, Math.min(30, current + delta));
        update.vote_results_duration = newVal;
    } else if (type === 'vulture_eat_count') {
        const current = settings.vulture_eat_count || 3;
        const newVal = Math.max(1, Math.min(10, current + delta));
        update.vulture_eat_count = newVal;
    }

    await fetch(`/api/games/${gameCode}/settings?session_token=${sessionToken}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(update)
    });
}

// ==================== MEETING COOLDOWN ====================

let meetingCooldownEnd = null;
let meetingCooldownInterval = null;

function startMeetingCooldown() {
    meetingCooldownEnd = Date.now() + (settings.meeting_cooldown * 1000);
    updateMeetingButtonCooldown();

    if (meetingCooldownInterval) clearInterval(meetingCooldownInterval);
    meetingCooldownInterval = setInterval(() => {
        updateMeetingButtonCooldown();
        if (Date.now() >= meetingCooldownEnd) {
            clearInterval(meetingCooldownInterval);
            meetingCooldownInterval = null;
        }
    }, 1000);
}

function updateMeetingButtonCooldown() {
    const btn = document.getElementById('call-meeting-btn');
    if (!btn) return;

    // If already used meeting, keep it disabled with "MEETING USED" text
    if (hasUsedMeeting) {
        btn.textContent = 'MEETING USED';
        btn.disabled = true;
        return;
    }

    if (meetingCooldownEnd && Date.now() < meetingCooldownEnd) {
        const remaining = Math.ceil((meetingCooldownEnd - Date.now()) / 1000);
        btn.textContent = `MEETING (${remaining}s)`;
        btn.disabled = true;
    } else {
        btn.textContent = 'CALL MEETING';
        btn.disabled = activeSabotage !== null;  // Still disabled during sabotage
    }

    // Also update captain button cooldown if it exists
    updateCaptainButtonCooldown();
}

function updateCaptainButtonCooldown() {
    const btn = document.getElementById('captain-meeting-btn');
    if (!btn || btn.style.display === 'none') return;

    // If already used, keep showing "REMOTE MEETING USED"
    if (btn.textContent === 'REMOTE MEETING USED') return;

    if (meetingCooldownEnd && Date.now() < meetingCooldownEnd) {
        const remaining = Math.ceil((meetingCooldownEnd - Date.now()) / 1000);
        btn.textContent = `REMOTE MEETING (${remaining}s)`;
        btn.disabled = true;
    } else {
        btn.textContent = 'REMOTE MEETING';
        btn.disabled = activeSabotage !== null;
    }
}

// ==================== SABOTAGE FUNCTIONS ====================

let activeSabotage = null;
let sabotageTimerInterval = null;
let sabotageCooldownEnd = null;
let sabotageCooldownInterval = null;

function startSabotageCooldownTimer() {
    if (sabotageCooldownInterval) clearInterval(sabotageCooldownInterval);

    updateImpostorSabotageButtons();

    sabotageCooldownInterval = setInterval(() => {
        updateImpostorSabotageButtons();
        if (!sabotageCooldownEnd || Date.now() >= sabotageCooldownEnd) {
            clearInterval(sabotageCooldownInterval);
            sabotageCooldownInterval = null;
        }
    }, 1000);
}

function toggleSabotageSettings() {
    const content = document.getElementById('sabotage-settings-content');
    const icon = document.getElementById('sabotage-toggle-icon');
    if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.textContent = '-';
    } else {
        content.style.display = 'none';
        icon.textContent = '+';
    }
}

function toggleAdvancedRoles() {
    const content = document.getElementById('advanced-roles-content');
    const icon = document.getElementById('advanced-roles-toggle-icon');
    if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.textContent = '-';
    } else {
        content.style.display = 'none';
        icon.textContent = '+';
    }
}

async function toggleAdvancedRole(roleKey) {
    const checkbox = document.getElementById(`role-${roleKey}`);
    const enabled = checkbox.checked;

    // Show/hide vulture eat count sub-setting
    if (roleKey === 'vulture') {
        const vultureSetting = document.getElementById('vulture-eat-setting');
        if (vultureSetting) vultureSetting.style.display = enabled ? 'flex' : 'none';
    }

    await fetch(`/api/games/${gameCode}/settings?session_token=${sessionToken}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            role_configs: {
                [roleKey]: { enabled: enabled }
            }
        })
    });
}

function updateAdvancedRolesUI() {
    const roleConfigs = settings.role_configs || {};
    const advancedRoles = ['engineer', 'captain', 'mayor', 'nice_guesser', 'spy', 'swapper',
                          'evil_guesser', 'bounty_hunter', 'cleaner', 'venter', 'vulture', 'noise_maker'];

    for (const roleKey of advancedRoles) {
        const checkbox = document.getElementById(`role-${roleKey}`);
        if (checkbox) {
            const config = roleConfigs[roleKey] || { enabled: false };
            checkbox.checked = config.enabled;
        }
    }

    // Update legacy roles that are now in advanced section
    document.getElementById('toggle-jester').checked = settings.enable_jester;
    document.getElementById('toggle-lonewolf').checked = settings.enable_lone_wolf;
    document.getElementById('toggle-minion').checked = settings.enable_minion;
    document.getElementById('toggle-sheriff').checked = settings.enable_sheriff;

    // Show/hide vulture eat count sub-setting
    const vultureConfig = roleConfigs['vulture'] || { enabled: false };
    const vultureSetting = document.getElementById('vulture-eat-setting');
    if (vultureSetting) {
        vultureSetting.style.display = vultureConfig.enabled ? 'flex' : 'none';
    }
    const vultureCountDisplay = document.getElementById('vulture-eat-count-display');
    if (vultureCountDisplay) {
        vultureCountDisplay.textContent = settings.vulture_eat_count || 3;
    }
}

async function toggleSabotageSetting() {
    const enabled = document.getElementById('toggle-sabotage').checked;
    document.getElementById('sabotage-config').style.display = enabled ? 'block' : 'none';

    await fetch(`/api/games/${gameCode}/settings?session_token=${sessionToken}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enable_sabotage: enabled })
    });
}

async function toggleSabotageItem(index) {
    const enabled = document.getElementById(`toggle-sab-${index}`).checked;
    const update = {};
    update[`sabotage_${index}_enabled`] = enabled;

    await fetch(`/api/games/${gameCode}/settings?session_token=${sessionToken}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(update)
    });
}

async function adjustSabotageTimer(index, delta) {
    const current = parseInt(document.getElementById(`sab-${index}-timer`).textContent) || 45;
    const newVal = Math.max(10, Math.min(120, current + delta));
    const update = {};
    update[`sabotage_${index}_timer`] = newVal;

    await fetch(`/api/games/${gameCode}/settings?session_token=${sessionToken}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(update)
    });
}

function updateSabotageSettingsUI() {
    document.getElementById('toggle-sabotage').checked = settings.enable_sabotage;
    document.getElementById('sabotage-config').style.display = settings.enable_sabotage ? 'block' : 'none';
    document.getElementById('setting-sabotage-cooldown').textContent = settings.sabotage_cooldown || 90;

    for (let i = 1; i <= 4; i++) {
        const enabled = settings[`sabotage_${i}_enabled`];
        const name = settings[`sabotage_${i}_name`];
        const timer = settings[`sabotage_${i}_timer`];

        const toggleEl = document.getElementById(`toggle-sab-${i}`);
        const nameEl = document.getElementById(`sab-${i}-name`);
        const timerEl = document.getElementById(`sab-${i}-timer`);

        if (toggleEl) toggleEl.checked = enabled;
        if (nameEl) nameEl.textContent = name;
        if (timerEl) timerEl.textContent = timer;
    }
}

// ==================== MEETING & VOTING SETTINGS ====================

function toggleMeetingSettings() {
    const content = document.getElementById('meeting-settings-content');
    const icon = document.getElementById('meeting-toggle-icon');
    if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.textContent = '-';
    } else {
        content.style.display = 'none';
        icon.textContent = '+';
    }
}

async function toggleVotingSetting() {
    const enabled = document.getElementById('toggle-voting').checked;

    // Update local settings immediately (optimistic update)
    settings.enable_voting = enabled;
    document.getElementById('voting-config').style.display = enabled ? 'block' : 'none';

    await fetch(`/api/games/${gameCode}/settings?session_token=${sessionToken}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enable_voting: enabled })
    });
}

async function toggleAnonymousVoting() {
    const anonymous = document.getElementById('toggle-anonymous').checked;

    // Update local settings immediately (optimistic update)
    settings.anonymous_voting = anonymous;

    await fetch(`/api/games/${gameCode}/settings?session_token=${sessionToken}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ anonymous_voting: anonymous })
    });
}

function updateMeetingSettingsUI() {
    const toggleVoting = document.getElementById('toggle-voting');
    const toggleAnonymous = document.getElementById('toggle-anonymous');
    const votingConfig = document.getElementById('voting-config');
    const timerDisplay = document.getElementById('setting-meeting-timer');
    const warningDisplay = document.getElementById('setting-meeting-warning');
    const discussionDisplay = document.getElementById('setting-discussion-time');

    if (toggleVoting) {
        toggleVoting.checked = settings.enable_voting || false;
    }
    if (toggleAnonymous) {
        toggleAnonymous.checked = settings.anonymous_voting || false;
    }
    if (votingConfig) {
        votingConfig.style.display = settings.enable_voting ? 'block' : 'none';
    }
    if (timerDisplay) {
        timerDisplay.textContent = settings.meeting_timer_duration || 120;
    }
    if (warningDisplay) {
        warningDisplay.textContent = settings.meeting_warning_time || 30;
    }
    if (discussionDisplay) {
        discussionDisplay.textContent = settings.discussion_time ?? 5;
    }
    const resultsTimerDisplay = document.getElementById('setting-vote-results-duration');
    if (resultsTimerDisplay) {
        resultsTimerDisplay.textContent = settings.vote_results_duration || 10;
    }
}

function showImpostorSabotageUI() {
    const section = document.getElementById('impostor-sabotage-section');
    if (!section) return;

    // Show for all impostor-aligned roles (except Minion) when sabotage is enabled
    if (IMPOSTOR_SABOTAGE_ROLES.includes(myRole) && settings.enable_sabotage) {
        section.style.display = 'block';
        updateImpostorSabotageButtons();
    } else {
        section.style.display = 'none';
    }
}

function updateImpostorSabotageButtons() {
    const buttonsDiv = document.getElementById('impostor-sabotage-buttons');
    if (!buttonsDiv) return;

    let html = '';
    for (let i = 1; i <= 4; i++) {
        const enabled = settings[`sabotage_${i}_enabled`];
        if (!enabled) continue;

        const name = settings[`sabotage_${i}_name`];
        const disabled = activeSabotage !== null || (sabotageCooldownEnd && Date.now() < sabotageCooldownEnd);

        html += `<button class="sabotage-btn ${disabled ? 'on-cooldown' : ''}"
                         onclick="startSabotage(${i})"
                         ${disabled ? 'disabled' : ''}>
                    ${name}
                </button>`;
    }

    buttonsDiv.innerHTML = html;

    // Update cooldown display
    const cooldownDiv = document.getElementById('impostor-sabotage-cooldown');
    if (sabotageCooldownEnd && Date.now() < sabotageCooldownEnd) {
        const remaining = Math.ceil((sabotageCooldownEnd - Date.now()) / 1000);
        cooldownDiv.style.display = 'block';
        document.getElementById('impostor-sabotage-cooldown-time').textContent = remaining;
    } else {
        cooldownDiv.style.display = 'none';
    }
}

async function startSabotage(index) {
    try {
        const response = await fetch(`/api/games/${gameCode}/sabotage/start?sabotage_index=${index}&session_token=${sessionToken}`, {
            method: 'POST'
        });

        if (!response.ok) {
            const data = await response.json();
            showError(data.detail || 'Failed to start sabotage');
        }
    } catch (e) {
        showError('Connection error');
    }
}

function handleSabotageStarted(payload) {
    activeSabotage = payload;

    // Update Engineer button if applicable
    updateEngineerButton();

    // Show alert
    document.getElementById('sabotage-alert').style.display = 'block';
    document.getElementById('active-sabotage-name').textContent = payload.name.toUpperCase() + '!';

    // Show timer if applicable
    if (payload.timer > 0) {
        document.getElementById('active-sabotage-timer').style.display = 'block';
        document.getElementById('sabotage-remaining').textContent = payload.timer;
        startSabotageTimer(payload.timer);
    } else {
        document.getElementById('active-sabotage-timer').style.display = 'none';
    }

    // Show appropriate fix button
    if (payload.type === 'reactor') {
        document.getElementById('fix-sabotage-btn').style.display = 'none';
        document.getElementById('hold-sabotage-btn').style.display = 'inline-block';
        document.getElementById('sabotage-fix-info').textContent = '2 people must HOLD simultaneously';
    } else if (payload.type === 'o2') {
        document.getElementById('fix-sabotage-btn').style.display = 'inline-block';
        document.getElementById('hold-sabotage-btn').style.display = 'none';
        document.getElementById('sabotage-fix-info').textContent = '2 switches needed (0/2)';
    } else {
        document.getElementById('fix-sabotage-btn').style.display = 'inline-block';
        document.getElementById('hold-sabotage-btn').style.display = 'none';
        document.getElementById('sabotage-fix-info').textContent = '';
    }

    // Disable call meeting during sabotage (report body still works)
    if (!hasUsedMeeting) {
        document.getElementById('call-meeting-btn').disabled = true;
    }

    // Update impostor UI
    updateImpostorSabotageButtons();

    // Play sabotage sound based on type
    if (payload.type === 'lights') {
        playSound('sound-lights-sabotage');
    } else {
        // Reactor and O2 use the same alarm sound
        playSound('sound-reactor-sabotage');
    }

    // Vibrate
    if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 100, 50, 100]);
}

function startSabotageTimer(seconds) {
    let remaining = seconds;

    if (sabotageTimerInterval) clearInterval(sabotageTimerInterval);

    sabotageTimerInterval = setInterval(async () => {
        remaining--;
        document.getElementById('sabotage-remaining').textContent = remaining;

        if (remaining <= 0) {
            clearInterval(sabotageTimerInterval);
            // Check timeout on server
            await fetch(`/api/games/${gameCode}/sabotage/check_timeout?session_token=${sessionToken}`, {
                method: 'POST'
            });
        }
    }, 1000);
}

function handleSabotageResolved(payload) {
    activeSabotage = null;

    // Update Engineer button if applicable
    updateEngineerButton();

    // Hide alert (except for lights which persists - but we still hide alert UI)
    document.getElementById('sabotage-alert').style.display = 'none';

    if (sabotageTimerInterval) {
        clearInterval(sabotageTimerInterval);
        sabotageTimerInterval = null;
    }

    // Re-enable meeting button (if not already used)
    if (!hasUsedMeeting) {
        document.getElementById('call-meeting-btn').disabled = false;
    }

    // Play fixed sound based on type
    if (payload.type === 'lights') {
        playSound('sound-lights-fixed');
    } else {
        // Reactor and O2 use the same fixed sound
        playSound('sound-reactor-fixed');
    }

    // Set cooldown and start timer for impostor UI
    sabotageCooldownEnd = Date.now() + (settings.sabotage_cooldown * 1000);

    // Start the cooldown timer to update UI (for impostor-aligned roles)
    if (IMPOSTOR_SABOTAGE_ROLES.includes(myRole)) {
        startSabotageCooldownTimer();
    }

    // Update impostor UI
    updateImpostorSabotageButtons();
}

function handleSabotageUpdate(payload) {
    if (payload.type === 'reactor') {
        document.getElementById('sabotage-fix-info').textContent = `${payload.holders}/2 people holding`;
    } else if (payload.type === 'o2') {
        document.getElementById('sabotage-fix-info').textContent = `${payload.switches}/2 switches`;
    }
}

async function fixSabotage() {
    try {
        await fetch(`/api/games/${gameCode}/sabotage/fix?session_token=${sessionToken}&action=tap`, {
            method: 'POST'
        });
    } catch (e) {
        showError('Failed to fix sabotage');
    }
}

async function holdReactorStart() {
    try {
        await fetch(`/api/games/${gameCode}/sabotage/fix?session_token=${sessionToken}&action=hold_start`, {
            method: 'POST'
        });
        document.getElementById('hold-sabotage-btn').textContent = 'HOLDING...';
        document.getElementById('hold-sabotage-btn').classList.add('holding');
    } catch (e) {
        showError('Failed to hold');
    }
}

async function holdReactorEnd() {
    try {
        await fetch(`/api/games/${gameCode}/sabotage/fix?session_token=${sessionToken}&action=hold_end`, {
            method: 'POST'
        });
        document.getElementById('hold-sabotage-btn').textContent = 'HOLD TO FIX';
        document.getElementById('hold-sabotage-btn').classList.remove('holding');
    } catch (e) {
        // Ignore
    }
}

async function toggleRole(role) {
    let update = {};
    if (role === 'jester') update.enable_jester = document.getElementById('toggle-jester').checked;
    if (role === 'lonewolf') update.enable_lone_wolf = document.getElementById('toggle-lonewolf').checked;
    if (role === 'minion') update.enable_minion = document.getElementById('toggle-minion').checked;
    if (role === 'sheriff') update.enable_sheriff = document.getElementById('toggle-sheriff').checked;

    await fetch(`/api/games/${gameCode}/settings?session_token=${sessionToken}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(update)
    });
}

async function startGame() {
    const btn = document.getElementById('start-game-btn');
    btn.disabled = true;
    btn.textContent = 'STARTING...';

    try {
        const response = await fetch(`/api/games/${gameCode}/start?session_token=${sessionToken}`, {
            method: 'POST'
        });

        if (!response.ok) {
            const data = await response.json();
            showError(data.detail || 'Failed to start game');
        }
    } catch (e) {
        showError('Connection error');
    } finally {
        btn.disabled = false;
        btn.textContent = 'START GAME';
    }
}

function handleGameStart(payload) {
    myRole = payload.role;
    updateRoleUI(payload);
    updateProgress(payload.task_percentage);
    showScreen('game-screen');

    // Scroll to top so player must scroll down to see their role
    window.scrollTo(0, 0);

    showCooldownTimer();

    // Play scary horror theme on game start
    playSound('sound-game-start');

    // Start kill cooldown timer at game start for impostor/bounty hunter/sheriff/lone wolf
    if (KILL_COOLDOWN_ROLES.includes(myRole)) {
        startCooldown();
    }

    // Start meeting cooldown at game start
    startMeetingCooldown();

    // Show sabotage UI for impostor-aligned roles (alive or dead can use it)
    if (IMPOSTOR_SABOTAGE_ROLES.includes(myRole) && settings.enable_sabotage) {
        showImpostorSabotageUI();
        // Start sabotage cooldown timer display
        sabotageCooldownEnd = Date.now() + (settings.sabotage_cooldown * 1000);
        startSabotageCooldownTimer();
    }
}

function updateRoleUI(roleInfo) {
    const roleDisplay = document.getElementById('role-display');
    const roleName = document.getElementById('role-name');
    const roleDesc = document.getElementById('role-description');
    const roleTeam = document.getElementById('role-team');
    const taskList = document.getElementById('task-list');
    const fellowImpostors = document.getElementById('fellow-impostors');
    const roleBadge = document.getElementById('role-badge');
    const roleNameBadge = document.getElementById('role-name-badge');

    roleName.textContent = roleInfo.role.toUpperCase();
    roleDisplay.className = 'role-display role-' + roleInfo.role.toLowerCase().replace(' ', '-');

    // Update compact role badge at top
    roleNameBadge.textContent = roleInfo.role.toUpperCase();
    roleBadge.className = 'role-badge role-' + roleInfo.role.toLowerCase().replace(' ', '-');

    // Team categorization
    const teams = {
        // Crewmate team
        'Crewmate': 'CREWMATE',
        'Sheriff': 'CREWMATE',
        'Engineer': 'CREWMATE',
        'Captain': 'CREWMATE',
        'Mayor': 'CREWMATE',
        'Bounty Hunter': 'CREWMATE',
        'Spy': 'CREWMATE',
        'Swapper': 'CREWMATE',
        // Impostor team
        'Impostor': 'IMPOSTOR',
        'Riddler': 'IMPOSTOR',
        'Rampager': 'IMPOSTOR',
        'Cleaner': 'IMPOSTOR',
        'Venter': 'IMPOSTOR',
        'Minion': 'IMPOSTOR',
        // Neutral
        'Jester': 'NEUTRAL',
        'Lone Wolf': 'NEUTRAL',
        'Vulture': 'NEUTRAL',
        'Noise Maker': 'CREWMATE'
    };
    const team = teams[roleInfo.role] || 'CREWMATE';
    roleTeam.textContent = team;
    roleTeam.className = 'role-team team-' + team.toLowerCase();

    const descriptions = {
        // Crewmate team
        'Crewmate': 'Complete your tasks. Find the impostors.',
        'Sheriff': 'Complete tasks. Whisper to shoot someone - miss and you die!',
        'Engineer': 'You can fix ONE sabotage remotely per game.',
        'Captain': 'Call a remote meeting from anywhere (one use per game).',
        'Mayor': 'Your vote counts twice during meetings.',
        'Bounty Hunter': 'During voting, guess a player\'s role. Wrong guess = you die.',
        'Spy': 'You appear as an impostor to the impostor team.',
        'Swapper': 'Swap votes between two players. Cannot call emergency meetings.',
        // Impostor team
        'Impostor': 'Eliminate crewmates. Don\'t get caught.',
        'Riddler': 'Like impostor, but can guess roles during voting. Wrong = you die.',
        'Rampager': 'Shorter cooldown killing your target, longer for others.',
        'Cleaner': 'You can clean bodies - drag them elsewhere before they\'re found.',
        'Venter': 'You can "vent" - access doors and walk outside the building.',
        'Minion': 'Help the impostors eliminate crewmates. You don\'t know who they are. You cannot kill.',
        // Neutral
        'Jester': 'Get yourself voted out to win!',
        'Lone Wolf': 'Survive until you\'re the last one standing.',
        'Vulture': `Eat ${roleInfo.bodies_needed || 3} bodies to win. Touch body & tell dead player to act alive.`,
        'Noise Maker': 'When killed, select who "found" you (fake body report).'
    };
    roleDesc.textContent = descriptions[roleInfo.role] || '';

    // Show tasks (no fake label shown - would reveal role if someone peeks at phone)
    taskList.innerHTML = roleInfo.tasks.map(t => `
        <div class="task-item ${t.status === 'completed' ? 'completed' : ''}" data-id="${t.id}">
            <span class="task-check" onclick="toggleTask('${t.id}')">${t.status === 'completed' ? '✓' : ''}</span>
            <span class="task-name">${t.name}</span>
        </div>
    `).join('');

    // Show fellow impostors
    if (roleInfo.fellow_impostors && roleInfo.fellow_impostors.length > 0) {
        fellowImpostors.style.display = 'block';
        document.getElementById('impostor-names').textContent = roleInfo.fellow_impostors.map(i => i.name).join(', ');
    } else {
        fellowImpostors.style.display = 'none';
    }

    // Show Jester voted out button only for Jesters
    const jesterBtn = document.getElementById('jester-voted-btn');
    jesterBtn.style.display = roleInfo.role === 'Jester' ? 'block' : 'none';

    // Show Engineer fix button only for Engineers
    const engineerBtn = document.getElementById('engineer-fix-btn');
    if (roleInfo.role === 'Engineer') {
        engineerBtn.style.display = 'block';
        if (roleInfo.remote_fix_available === false) {
            engineerBtn.disabled = true;
            engineerBtn.textContent = 'FIX USED';
        } else if (!activeSabotage) {
            engineerBtn.disabled = true;
            engineerBtn.textContent = 'NO ACTIVE SABOTAGE';
        } else {
            engineerBtn.disabled = false;
            engineerBtn.textContent = 'FIX SABOTAGE REMOTELY';
        }
    } else {
        engineerBtn.style.display = 'none';
    }

    // Show Captain remote meeting button only for Captains
    const captainBtn = document.getElementById('captain-meeting-btn');
    if (roleInfo.role === 'Captain') {
        captainBtn.style.display = 'block';
        if (roleInfo.extra_meeting_available === false) {
            captainBtn.disabled = true;
            captainBtn.textContent = 'REMOTE MEETING USED';
        } else {
            captainBtn.disabled = false;
            captainBtn.textContent = 'REMOTE MEETING';
        }
    } else {
        captainBtn.style.display = 'none';
    }

    // Show Vulture eat section only for Vultures
    const vultureSection = document.getElementById('vulture-eat-section');
    if (roleInfo.role === 'Vulture') {
        vultureSection.style.display = 'block';
        document.getElementById('vulture-count').textContent = roleInfo.bodies_eaten || 0;
        document.getElementById('vulture-needed').textContent = roleInfo.bodies_needed || 3;
        vultureEatenBodyIds = roleInfo.eaten_body_ids || [];
        vultureIneligibleBodyIds = roleInfo.ineligible_body_ids || [];
        updateVultureBodyList();
    } else {
        vultureSection.style.display = 'none';
    }

    // Show Rampager section
    const bountySection = document.getElementById('bounty-hunter-section');
    if (roleInfo.role === 'Rampager') {
        bountySection.style.display = 'block';
        bountyKills = roleInfo.bounty_kills || 0;
        if (roleInfo.bounty_target) {
            document.getElementById('bounty-target-name').textContent = roleInfo.bounty_target.name;
            bountyTargetId = roleInfo.bounty_target.id;
        } else {
            document.getElementById('bounty-target-name').textContent = 'No target';
            bountyTargetId = null;
        }
        updateBountyKillButton();
    } else {
        bountySection.style.display = 'none';
    }
}

function updateProgress(percentage) {
    const fills = document.querySelectorAll('.progress-fill');
    const texts = document.querySelectorAll('.progress-text');

    fills.forEach(fill => fill.style.width = percentage + '%');
    texts.forEach(text => text.textContent = percentage + '% Tasks Complete');
}

async function toggleTask(taskId) {
    const taskEl = document.querySelector(`.task-item[data-id="${taskId}"]`);
    if (!taskEl) return;

    const isCompleted = taskEl.classList.contains('completed');

    // Crew-aligned roles (except Minion) have real tasks that update the server
    if (REAL_TASK_ROLES.includes(myRole)) {
        const endpoint = isCompleted ? 'uncomplete' : 'complete';
        try {
            const response = await fetch(`/api/tasks/${taskId}/${endpoint}?session_token=${sessionToken}`, {
                method: 'POST'
            });

            if (response.ok) {
                toggleTaskUI(taskEl, isCompleted);
            }
        } catch (e) {
            console.error('Failed to toggle task:', e);
        }
    } else {
        // For other roles (Impostor, Jester, etc.), just toggle UI locally (fake tasks)
        toggleTaskUI(taskEl, isCompleted);
    }
}

function toggleTaskUI(taskEl, wasCompleted) {
    if (wasCompleted) {
        taskEl.classList.remove('completed');
        taskEl.querySelector('.task-check').textContent = '';
    } else {
        taskEl.classList.add('completed');
        taskEl.querySelector('.task-check').textContent = '✓';
    }
}

async function callMeeting() {
    const btn = document.getElementById('call-meeting-btn');

    // Can only call meeting once per game
    if (hasUsedMeeting) {
        return;
    }

    // Check meeting cooldown
    if (meetingCooldownEnd && Date.now() < meetingCooldownEnd) {
        return;  // Still on cooldown
    }

    // Check if sabotage is active (can't call meeting during sabotage)
    if (activeSabotage) {
        showError('Cannot call meeting during sabotage!');
        return;
    }

    btn.disabled = true;

    try {
        const response = await fetch(`/api/games/${gameCode}/meeting/start?session_token=${sessionToken}`, {
            method: 'POST'
        });
        if (response.ok) {
            // Mark meeting as used - can't use again this game
            hasUsedMeeting = true;
            btn.textContent = 'MEETING USED';
            btn.disabled = true;
        }
    } catch (e) {
        showError('Failed to call meeting');
        btn.disabled = false;
    }
}

async function reportBody() {
    // Report body always works - no cooldown constraint
    const btn = document.getElementById('report-body-btn');
    btn.disabled = true;

    try {
        await fetch(`/api/games/${gameCode}/meeting/start?session_token=${sessionToken}&meeting_type=body_report`, {
            method: 'POST'
        });
    } catch (e) {
        showError('Failed to report body');
    } finally {
        btn.disabled = false;
    }
}

function handleMeetingStart(payload) {
    // ALWAYS reset meeting state first - clean slate!
    resetMeetingState();
    guesserDead = false;  // Reset guesser state for new meeting

    // Update consolidated meeting state
    meetingState.phase = 'gathering';
    meetingState.callerId = payload.caller_id;
    meetingState.callerName = payload.called_by;
    meetingState.meetingType = payload.meeting_type;
    meetingState.votingEnabled = payload.enable_voting || false;
    meetingState.payload = payload;

    // Setup meeting header
    const meetingHeader = document.getElementById('meeting-header');
    const meetingTitle = document.getElementById('meeting-title');
    const meetingCaller = document.getElementById('meeting-caller');

    // Display differently for body report vs emergency meeting
    // HIDE reporter identity until meeting officially starts
    if (payload.meeting_type === 'body_report') {
        meetingHeader.classList.add('body-report');
        meetingTitle.textContent = 'DEAD BODY REPORTED';
        meetingCaller.textContent = '';  // Hidden until meeting starts
    } else {
        meetingHeader.classList.remove('body-report');
        meetingTitle.textContent = 'EMERGENCY MEETING';
        meetingCaller.textContent = '';  // Hidden until meeting starts
    }

    updateProgress(payload.task_percentage);

    // Mark all currently dead bodies as ineligible for vulture (discovered in meeting)
    if (myRole === 'Vulture') {
        payload.dead_players.forEach(p => {
            if (!vultureIneligibleBodyIds.includes(p.id)) {
                vultureIneligibleBodyIds.push(p.id);
            }
        });
    }

    // Populate player lists
    document.getElementById('alive-list').innerHTML = payload.alive_players.map(p => `
        <div class="player-item">${p.name}</div>
    `).join('');

    document.getElementById('dead-list').innerHTML = payload.dead_players.map(p => `
        <div class="player-item dead">${p.name}</div>
    `).join('');

    // Reset vote feed
    const voteFeed = document.getElementById('vote-feed');
    voteFeed.innerHTML = '';
    voteFeed.style.display = 'none';

    // Close Noise Maker selection modal if open (edge case: another player reports body first)
    const noiseMakerModal = document.getElementById('noise-maker-modal');
    if (noiseMakerModal) {
        noiseMakerModal.style.display = 'none';
    }

    // Hide lights sabotage banner during meeting (will re-show on meeting end if still active)
    if (activeSabotage && activeSabotage.type === 'lights') {
        document.getElementById('sabotage-alert').style.display = 'none';
    }

    // Render UI based on phase
    renderMeetingPhase();

    showScreen('meeting-screen');

    // Play meeting sound
    playSound('sound-meeting');

    // Vibrate (if enabled)
    if (settings.vibrate_meeting && navigator.vibrate) navigator.vibrate([200, 100, 200]);
}

async function startVotingPhase() {
    // Called when the meeting caller clicks START MEETING
    const btn = document.getElementById('start-meeting-btn');
    btn.disabled = true;
    btn.textContent = 'Starting...';

    try {
        const response = await fetch(`/api/games/${gameCode}/meeting/start_voting?session_token=${sessionToken}`, {
            method: 'POST'
        });

        if (!response.ok) {
            const data = await response.json();
            showError(data.detail || 'Failed to start meeting');
            btn.disabled = false;
            btn.textContent = 'START MEETING';
        }
        // Success - WebSocket will broadcast voting_started to everyone
    } catch (e) {
        showError('Failed to start meeting');
        btn.disabled = false;
        btn.textContent = 'START MEETING';
    }
}

function handleVotingStarted(payload) {
    // Update meeting state
    meetingState.phase = 'voting';
    meetingState.hasVoted = false;

    // Store timestamps for reference
    const now = Date.now();
    const discussionTime = payload.discussion_time || 0;
    const timerDuration = payload.timer_duration || 120;
    meetingState.discussionEndsAt = now + (discussionTime * 1000);
    meetingState.votingEndsAt = now + (timerDuration * 1000);

    // Render phase UI (hides gathering, shows voting)
    renderMeetingPhase();

    // NOW reveal who called the meeting
    const meetingCaller = document.getElementById('meeting-caller');
    if (meetingState.meetingType === 'body_report') {
        meetingCaller.textContent = `Reported by ${meetingState.callerName}`;
    } else {
        meetingCaller.textContent = `Called by ${meetingState.callerName}`;
    }

    // Check if current player is alive (only alive players can vote)
    const me = allPlayers.find(p => p.id === playerId);
    const amAlive = me && me.status !== 'dead';
    // Also check if we're in the dead list
    const inDeadList = meetingState.payload && meetingState.payload.dead_players.some(p => p.id === playerId);
    const canVote = amAlive && !inDeadList;

    // Setup voting UI
    const votingSection = document.getElementById('voting-section');
    const voteOptions = document.getElementById('vote-options');
    const skipBtn = document.getElementById('skip-vote-btn');

    const isGuesser = GUESSER_ROLES.includes(myRole);

    // Check if any guesser role is enabled in game settings
    const roleConfigs = settings.role_configs || {};
    const hasGuessersInGame = (roleConfigs.nice_guesser && roleConfigs.nice_guesser.enabled) ||
                              (roleConfigs.evil_guesser && roleConfigs.evil_guesser.enabled);

    if (canVote) {
        // Populate vote options with alive players (including self - Jester strategy!)
        voteOptions.innerHTML = payload.alive_players
            .map(p => `
                <div class="vote-btn-wrapper" style="display: flex; gap: 4px; margin-bottom: 4px;">
                    <button class="btn vote-btn" onclick="castVote('${p.id}')" ${discussionTime > 0 ? 'disabled' : ''} style="flex: 1;">
                        ${p.name}
                    </button>
                    ${hasGuessersInGame && p.id !== playerId ? `<button class="btn guesser-guess-btn" onclick="handleGuessButton('${p.id}', '${p.name}')" ${discussionTime > 0 ? 'disabled' : ''} style="width: 36px; min-width: 36px; padding: 0; font-size: 16px; background: #14b8a6;">?</button>` : ''}
                </div>
            `).join('');

        // Setup skip button
        skipBtn.style.display = 'block';
        skipBtn.disabled = discussionTime > 0;
        skipBtn.classList.remove('voted');
    } else {
        // Dead players see a message instead of voting options
        voteOptions.innerHTML = '<div class="dead-voter-message">You are dead. You cannot vote.</div>';
        skipBtn.style.display = 'none';
    }

    // Update vote counts
    document.getElementById('votes-cast-count').textContent = '0';
    document.getElementById('votes-needed-count').textContent = payload.alive_players.length;

    // Handle discussion time countdown
    if (discussionTime > 0) {
        // Show discussion countdown in the voting section header
        const votingHeader = votingSection.querySelector('h3');
        let remaining = discussionTime;
        votingHeader.textContent = `Discussion Time: ${remaining}s`;
        votingHeader.classList.add('discussion-countdown');

        discussionTimerInterval = setInterval(() => {
            remaining--;
            if (remaining > 0) {
                votingHeader.textContent = `Discussion Time: ${remaining}s`;
            } else {
                // Discussion time ended - enable voting!
                clearInterval(discussionTimerInterval);
                discussionTimerInterval = null;
                votingHeader.textContent = 'Vote to Eliminate';
                votingHeader.classList.remove('discussion-countdown');

                // Play "time to vote" sound when voting begins
                playSound('sound-time-to-vote');

                // Enable all vote buttons (including guesser buttons)
                if (canVote) {
                    voteOptions.querySelectorAll('.vote-btn, .guesser-guess-btn').forEach(btn => btn.disabled = false);
                    skipBtn.disabled = false;
                }
            }
        }, 1000);

        // Start the full meeting timer (includes discussion time)
        startMeetingTimer(timerDuration, payload.warning_time || 30);
    } else {
        // No discussion time - play sound and enable voting immediately
        playSound('sound-time-to-vote');

        // Start meeting timer
        startMeetingTimer(timerDuration, payload.warning_time || 30);
    }

    // Show Swapper UI if player is Swapper and alive
    const swapperSection = document.getElementById('swapper-section');
    if (myRole === 'Swapper' && canVote) {
        swapperSection.style.display = 'block';
        swapPlayer1 = null;
        swapPlayer2 = null;
        swapConfirmed = false;
        document.getElementById('swap-player1-btn').textContent = '[Select Player 1]';
        document.getElementById('swap-player2-btn').textContent = '[Select Player 2]';
        document.getElementById('confirm-swap-btn').disabled = true;
        document.getElementById('swapper-controls').style.display = 'block';
        document.getElementById('swapper-result').style.display = 'none';
        swapAlivePlayers = payload.alive_players;
    } else {
        swapperSection.style.display = 'none';
    }
}

// ==================== VOTING FUNCTIONS ====================

function startMeetingTimer(durationSeconds, warningTime) {
    if (meetingTimerInterval) clearInterval(meetingTimerInterval);

    meetingEndTime = Date.now() + (durationSeconds * 1000);
    meetingState.warningPlayed = false;

    updateMeetingTimerDisplay();
    meetingTimerInterval = setInterval(() => {
        updateMeetingTimerDisplay();

        const remaining = Math.max(0, meetingEndTime - Date.now());
        const remainingSeconds = Math.ceil(remaining / 1000);

        // Play warning sound
        if (!meetingState.warningPlayed && remainingSeconds <= warningTime && remainingSeconds > 0) {
            meetingState.warningPlayed = true;
            playSound('sound-voting-warning');
            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
        }

        // Timer expired
        if (remaining <= 0) {
            clearInterval(meetingTimerInterval);
            meetingTimerInterval = null;
            handleTimerExpired();
        }
    }, 100);
}

function updateMeetingTimerDisplay() {
    const display = document.getElementById('meeting-timer-display');
    if (!meetingEndTime) {
        display.textContent = '0:00';
        return;
    }

    const remaining = Math.max(0, meetingEndTime - Date.now());
    const totalSeconds = Math.ceil(remaining / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;

    display.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

    // Add warning class when low
    const timerCircle = document.querySelector('.timer-circle');
    if (timerCircle) {
        if (totalSeconds <= 30) {
            timerCircle.classList.add('warning');
        } else {
            timerCircle.classList.remove('warning');
        }
        if (totalSeconds <= 10) {
            timerCircle.classList.add('critical');
        } else {
            timerCircle.classList.remove('critical');
        }
    }
}

async function handleTimerExpired() {
    // Notify server that timer expired
    try {
        await fetch(`/api/games/${gameCode}/meeting/timer_expired?session_token=${sessionToken}`, {
            method: 'POST'
        });
    } catch (e) {
        console.error('Failed to notify timer expired:', e);
    }
}

async function castVote(targetId) {
    if (meetingState.hasVoted) return;

    // Disable all vote buttons immediately
    const allVoteBtns = document.querySelectorAll('.vote-btn, #skip-vote-btn');
    allVoteBtns.forEach(btn => btn.disabled = true);

    try {
        const url = targetId
            ? `/api/games/${gameCode}/vote?session_token=${sessionToken}&target_id=${targetId}`
            : `/api/games/${gameCode}/vote?session_token=${sessionToken}`;

        const response = await fetch(url, { method: 'POST' });

        if (response.ok) {
            meetingState.hasVoted = true;
            // Highlight the selected vote
            if (targetId) {
                const votedBtn = document.querySelector(`.vote-btn[onclick="castVote('${targetId}')"]`);
                if (votedBtn) votedBtn.classList.add('voted');
            } else {
                document.getElementById('skip-vote-btn').classList.add('voted');
            }
        } else {
            // Re-enable buttons on error
            allVoteBtns.forEach(btn => btn.disabled = false);
            const data = await response.json();
            showError(data.detail || 'Failed to cast vote');
        }
    } catch (e) {
        // Re-enable buttons on error
        allVoteBtns.forEach(btn => btn.disabled = false);
        showError('Connection error');
    }
}

function handleVoteCast(payload) {
    // Update vote count display only - individual votes shown at results
    document.getElementById('votes-cast-count').textContent = payload.votes_cast;
    document.getElementById('votes-needed-count').textContent = payload.votes_needed;
}

function handleVoteResults(payload) {
    // Update meeting state to results phase
    meetingState.phase = 'results';

    // Stop the timer
    if (meetingTimerInterval) {
        clearInterval(meetingTimerInterval);
        meetingTimerInterval = null;
    }
    if (discussionTimerInterval) {
        clearInterval(discussionTimerInterval);
        discussionTimerInterval = null;
    }

    // Play "time to vote" sound (voting ended)
    playSound('sound-time-to-vote');

    // Render results phase UI
    renderMeetingPhase();

    // Debug: log the payload to see what we're getting
    console.log('Vote results payload:', payload);

    // Display vote counts with voters listed under each name
    const resultsList = document.getElementById('vote-results-list');
    let resultsHtml = '';

    // Sort by vote count descending
    const sortedResults = Object.entries(payload.vote_counts)
        .sort((a, b) => b[1] - a[1]);

    // Get votes_by_target for showing who voted for whom
    const votesByTarget = payload.votes_by_target || {};

    const swappedNames = payload.swapped_names || [];

    for (const [name, count] of sortedResults) {
        const isEliminated = payload.eliminated_name === name;
        const isSwapped = swappedNames.includes(name);
        const voters = votesByTarget[name] || [];
        const votersText = voters.length > 0 ? `(${voters.join(', ')})` : '';

        resultsHtml += `
            <div class="vote-result-item ${isEliminated ? 'eliminated' : ''}">
                <div class="vote-result-main">
                    <span class="vote-result-name">${name}${isSwapped ? ' <span style="color: #ec4899; font-size: 12px;">(Swapped)</span>' : ''}</span>
                    <span class="vote-result-count">${count} vote${count !== 1 ? 's' : ''}</span>
                </div>
                ${votersText ? `<div class="vote-result-voters">${votersText}</div>` : ''}
            </div>
        `;
    }

    // Show skip votes
    if (payload.skip_count > 0) {
        const skipVoters = votesByTarget['Skip'] || [];
        const skipVotersText = skipVoters.length > 0 ? `(${skipVoters.join(', ')})` : '';

        resultsHtml += `
            <div class="vote-result-item skip">
                <div class="vote-result-main">
                    <span class="vote-result-name">Skip</span>
                    <span class="vote-result-count">${payload.skip_count} vote${payload.skip_count !== 1 ? 's' : ''}</span>
                </div>
                ${skipVotersText ? `<div class="vote-result-voters">${skipVotersText}</div>` : ''}
            </div>
        `;
    }

    resultsList.innerHTML = resultsHtml;

    // Display outcome
    const outcomeEl = document.getElementById('vote-outcome');
    if (payload.eliminated_name) {
        outcomeEl.textContent = `${payload.eliminated_name} was ejected.`;
        outcomeEl.className = 'vote-outcome ejected';
    } else if (payload.outcome === 'tie') {
        outcomeEl.textContent = 'No one was ejected. (Tie)';
        outcomeEl.className = 'vote-outcome no-eject';
    } else {
        outcomeEl.textContent = 'No one was ejected. (Skipped)';
        outcomeEl.className = 'vote-outcome no-eject';
    }

    // Hide the old vote feed (we now show voters inline)
    const voteFeed = document.getElementById('vote-feed');
    voteFeed.style.display = 'none';

    // Start vote results countdown before showing END MEETING button
    const duration = settings.vote_results_duration || 10;
    let remaining = duration;
    const countdownEl = document.getElementById('vote-results-countdown');
    const endBtn = document.getElementById('end-meeting-btn');
    endBtn.style.display = 'none';
    countdownEl.textContent = `Returning in ${remaining}s...`;

    if (voteResultsTimerInterval) clearInterval(voteResultsTimerInterval);
    voteResultsTimerInterval = setInterval(() => {
        remaining--;
        if (remaining <= 0) {
            clearInterval(voteResultsTimerInterval);
            voteResultsTimerInterval = null;
            countdownEl.textContent = '';
            // Show END MEETING button for everyone
            endBtn.style.display = 'block';
        } else {
            countdownEl.textContent = `Returning in ${remaining}s...`;
        }
    }, 1000);
}

async function endMeeting() {
    try {
        await fetch(`/api/games/${gameCode}/meeting/end?session_token=${sessionToken}`, {
            method: 'POST'
        });
    } catch (e) {
        showError('Failed to end meeting');
    }
}

function handleMeetingEnd() {
    // CLEAN SLATE: Reset all meeting state
    resetMeetingState();

    showScreen('game-screen');

    // Ensure dead players' buttons stay disabled after meeting
    const me = allPlayers.find(p => p.id === playerId);
    if (me && me.status === 'dead') {
        document.getElementById('im-dead-btn').disabled = true;
        document.getElementById('im-dead-btn').textContent = 'YOU ARE DEAD';
        const meetBtn = document.getElementById('call-meeting-btn');
        meetBtn.disabled = true;
        meetBtn.textContent = 'YOU ARE DEAD';
        meetBtn.className = 'btn btn-secondary';
        document.getElementById('report-body-btn').disabled = true;
    }

    // Reset kill cooldown timer after meeting for impostor/bounty hunter/sheriff/lone wolf
    if (KILL_COOLDOWN_ROLES.includes(myRole)) {
        startCooldown();
    }

    // Start meeting cooldown for everyone
    startMeetingCooldown();

    // Re-show lights sabotage alert if still active (lights persists through meetings)
    if (activeSabotage && activeSabotage.type === 'lights') {
        document.getElementById('sabotage-alert').style.display = 'block';
        playSound('sound-lights-sabotage');  // Remind players lights are still off
        // Disable call meeting during sabotage (if not already used)
        if (!hasUsedMeeting) {
            document.getElementById('call-meeting-btn').disabled = true;
        }
    }

    // Reset sabotage cooldown after meeting for impostor-aligned roles
    if (IMPOSTOR_SABOTAGE_ROLES.includes(myRole) && settings.enable_sabotage) {
        sabotageCooldownEnd = Date.now() + (settings.sabotage_cooldown * 1000);
        startSabotageCooldownTimer();
        updateImpostorSabotageButtons();
    }

    // Update vulture body list (ineligible bodies removed after meeting)
    if (myRole === 'Vulture') {
        updateVultureBodyList();
    }
}

async function markDead() {
    if (!confirm('Are you sure you want to mark yourself as dead?')) return;

    try {
        const resp = await fetch(`/api/players/${playerId}/die?session_token=${sessionToken}`, {
            method: 'POST'
        });
        const data = await resp.json();

        document.getElementById('im-dead-btn').disabled = true;
        document.getElementById('im-dead-btn').textContent = 'YOU ARE DEAD';
        const deadMeetingBtn = document.getElementById('call-meeting-btn');
        deadMeetingBtn.disabled = true;
        deadMeetingBtn.textContent = 'YOU ARE DEAD';
        deadMeetingBtn.className = 'btn btn-secondary';
        document.getElementById('report-body-btn').disabled = true;

        // Noise Maker: show target selection modal
        if (data.noise_maker) {
            showNoiseMakerSelect();
        }
    } catch (e) {
        showError('Failed to mark as dead');
    }
}

async function jesterVotedOut() {
    if (!confirm('Did you get voted out? This will end the game with a Jester victory!')) return;

    try {
        await fetch(`/api/players/${playerId}/jester-win?session_token=${sessionToken}`, {
            method: 'POST'
        });

        document.getElementById('jester-voted-btn').disabled = true;
        document.getElementById('jester-voted-btn').textContent = 'JESTER WINS!';
    } catch (e) {
        showError('Failed to claim victory');
    }
}

// ==================== ROLE ABILITY FUNCTIONS ====================

function updateEngineerButton() {
    const btn = document.getElementById('engineer-fix-btn');
    if (!btn || btn.style.display === 'none') return;
    // Don't update if already used
    if (btn.textContent === 'FIX USED') return;

    if (activeSabotage) {
        btn.disabled = false;
        btn.textContent = 'FIX SABOTAGE REMOTELY';
    } else {
        btn.disabled = true;
        btn.textContent = 'NO ACTIVE SABOTAGE';
    }
}

async function engineerFix() {
    const btn = document.getElementById('engineer-fix-btn');
    if (btn.disabled) return;

    if (!confirm('Use your ONE remote fix to resolve the active sabotage?')) return;

    btn.disabled = true;
    try {
        const response = await fetch(`/api/games/${gameCode}/ability/engineer-fix?session_token=${sessionToken}`, {
            method: 'POST'
        });
        if (response.ok) {
            btn.textContent = 'FIX USED';
        } else {
            const data = await response.json();
            showError(data.detail || 'Failed to fix sabotage');
            btn.disabled = false;
        }
    } catch (e) {
        showError('Failed to fix sabotage');
        btn.disabled = false;
    }
}

async function captainMeeting() {
    const btn = document.getElementById('captain-meeting-btn');
    if (btn.disabled) return;

    // Check if sabotage is active
    if (activeSabotage) {
        showError('Cannot call meeting during sabotage!');
        return;
    }

    // Respect meeting cooldown (button already shows countdown via updateCaptainButtonCooldown)
    if (meetingCooldownEnd && Date.now() < meetingCooldownEnd) {
        return;
    }

    btn.disabled = true;
    try {
        const response = await fetch(`/api/games/${gameCode}/ability/captain-meeting?session_token=${sessionToken}`, {
            method: 'POST'
        });
        if (response.ok) {
            btn.textContent = 'REMOTE MEETING USED';
        } else {
            const data = await response.json();
            showError(data.detail || 'Failed to call meeting');
            btn.disabled = false;
        }
    } catch (e) {
        showError('Failed to call meeting');
        btn.disabled = false;
    }
}

// ==================== RAMPAGER ====================

function updateBountyKillButton() {
    const section = document.getElementById('bounty-hunter-section');
    if (!section || section.style.display === 'none') return;

    const wasItYou = document.getElementById('bounty-was-it-you');
    const killsDisplay = document.getElementById('bounty-kills-display');

    // Update kills counter
    if (killsDisplay) {
        killsDisplay.textContent = bountyKills > 0 ? `${bountyKills} bounty kill${bountyKills !== 1 ? 's' : ''}` : '';
    }

    if (!bountyTargetId) {
        wasItYou.style.display = 'none';
        return;
    }

    const target = allPlayers.find(p => p.id === bountyTargetId);
    if (target && target.status === 'dead') {
        // Target died! Show "Was it you?" prompt
        wasItYou.style.display = 'block';
        document.getElementById('bounty-prompt-text').textContent =
            `Your target ${target.name} is dead! Was it you?`;
    } else {
        wasItYou.style.display = 'none';
    }
}

async function bountyKillClaim(claimed) {
    const wasItYou = document.getElementById('bounty-was-it-you');
    wasItYou.style.display = 'none';

    try {
        const resp = await fetch(`/api/games/${gameCode}/ability/bounty-kill?session_token=${sessionToken}&claimed=${claimed}`, {
            method: 'POST'
        });
        const data = await resp.json();
        if (data.success) {
            bountyKills = data.bounty_kills;
            bountyTargetId = data.new_target_id;
            document.getElementById('bounty-target-name').textContent = data.new_target_name || 'No target';
            updateBountyKillButton();
        } else {
            showError(data.detail || 'Failed');
        }
    } catch (e) {
        showError('Failed to process bounty');
}

// ==================== SWAPPER ====================

let swapPlayer1 = null;
let swapPlayer2 = null;
let swapConfirmed = false;
let swapAlivePlayers = [];
let swapSelectSlot = 0;  // Which slot we're selecting for (1 or 2)

function openSwapSelect(slot) {
    if (swapConfirmed) return;
    swapSelectSlot = slot;
    const modal = document.getElementById('swap-select-modal');
    const options = document.getElementById('swap-select-options');
    options.innerHTML = swapAlivePlayers.map(p => `
        <button class="btn btn-secondary" onclick="selectSwapPlayer('${p.id}', '${p.name}')" style="width: 100%; margin-bottom: 4px; font-size: 13px;">${p.name}</button>
    `).join('');
    modal.style.display = 'flex';
}

function closeSwapSelect() {
    document.getElementById('swap-select-modal').style.display = 'none';
}

function selectSwapPlayer(id, name) {
    if (swapSelectSlot === 1) {
        swapPlayer1 = { id, name };
        document.getElementById('swap-player1-btn').textContent = name;
    } else {
        swapPlayer2 = { id, name };
        document.getElementById('swap-player2-btn').textContent = name;
    }
    closeSwapSelect();

    // Enable confirm button if both selected
    document.getElementById('confirm-swap-btn').disabled = !(swapPlayer1 && swapPlayer2);
}

async function confirmSwap() {
    if (!swapPlayer1 || !swapPlayer2 || swapConfirmed) return;

    swapConfirmed = true;
    document.getElementById('confirm-swap-btn').disabled = true;

    try {
        const resp = await fetch(`/api/games/${gameCode}/ability/swapper-swap?session_token=${sessionToken}&player1_id=${swapPlayer1.id}&player2_id=${swapPlayer2.id}`, {
            method: 'POST'
        });
        const data = await resp.json();
        if (resp.ok) {
            document.getElementById('swapper-controls').style.display = 'none';
            document.getElementById('swapper-result').style.display = 'block';
            document.getElementById('swapper-result').textContent = `Swap set: ${swapPlayer1.name} ↔ ${swapPlayer2.name}`;
        } else {
            showError(data.detail || 'Swap failed');
            swapConfirmed = false;
            document.getElementById('confirm-swap-btn').disabled = false;
        }
    } catch (e) {
        showError('Failed to set swap');
        swapConfirmed = false;
        document.getElementById('confirm-swap-btn').disabled = false;
    }
}

// ==================== GUESSER ====================

let guesserTargetId = null;
let guesserTargetName = null;
let guesserDead = false;

function handleGuessButton(targetId, targetName) {
    const isGuesser = GUESSER_ROLES.includes(myRole);
    if (isGuesser) {
        openGuesserModal(targetId, targetName);
    }
    // Non-guessers: do nothing (button is just for disguise)
}

function openGuesserModal(targetId, targetName) {
    if (guesserDead) return;
    guesserTargetId = targetId;
    guesserTargetName = targetName;

    document.getElementById('guesser-target-label').textContent = `Guessing ${targetName}'s role:`;

    // Build role options from cached role guide or from all known roles
    const allRoles = [
        { name: 'Crewmate', color: '#4ade80' },
        { name: 'Sheriff', color: '#3b82f6' },
        { name: 'Engineer', color: '#22c55e' },
        { name: 'Captain', color: '#0ea5e9' },
        { name: 'Mayor', color: '#8b5cf6' },
        { name: 'Bounty Hunter', color: '#14b8a6' },
        { name: 'Spy', color: '#6366f1' },
        { name: 'Swapper', color: '#ec4899' },
        { name: 'Impostor', color: '#ef4444' },
        { name: 'Riddler', color: '#dc2626' },
        { name: 'Rampager', color: '#b91c1c' },
        { name: 'Cleaner', color: '#991b1b' },
        { name: 'Venter', color: '#7c2d12' },
        { name: 'Minion', color: '#eab308' },
        { name: 'Jester', color: '#a855f7' },
        { name: 'Lone Wolf', color: '#f97316' },
        { name: 'Vulture', color: '#84cc16' },
        { name: 'Noise Maker', color: '#f59e0b' }
    ];

    // Crew guesser (Bounty Hunter): only show generic "Impostor" option
    // Impostor guesser (Riddler): show all roles (can guess anyone as anything)
    let displayRoles;
    if (myRole === 'Bounty Hunter') {
        displayRoles = allRoles.filter(r => !IMPOSTOR_SUBTYPES.includes(r.name));
    } else {
        displayRoles = allRoles;
    }

    const options = document.getElementById('guesser-role-options');
    options.innerHTML = displayRoles.map(r => `
        <button class="btn" onclick="confirmGuesserGuess('${r.name}')" style="width: 100%; margin-bottom: 4px; font-size: 13px; background: rgba(255,255,255,0.05); border: 1px solid ${r.color}; color: ${r.color};">
            ${r.name}
        </button>
    `).join('');

    document.getElementById('guesser-modal').style.display = 'flex';
}

function closeGuesserModal() {
    document.getElementById('guesser-modal').style.display = 'none';
    guesserTargetId = null;
    guesserTargetName = null;
}

async function confirmGuesserGuess(roleName) {
    if (!guesserTargetId || guesserDead) return;

    if (!confirm(`Guess ${guesserTargetName} is ${roleName}?\n\nWrong guess = YOU DIE!`)) return;

    closeGuesserModal();

    try {
        const resp = await fetch(`/api/games/${gameCode}/ability/guesser-guess?session_token=${sessionToken}&target_id=${guesserTargetId}&guessed_role=${encodeURIComponent(roleName)}`, {
            method: 'POST'
        });
        // Result handled via WebSocket broadcast (guesser_result)
        if (!resp.ok) {
            const data = await resp.json();
            showError(data.detail || 'Guess failed');
        }
    } catch (e) {
        showError('Failed to submit guess');
    }
}

function handleGuesserResult(payload) {
    // Play death during meeting sound
    playSound('sound-death-meeting');

    // If the dead player is ME, show death overlay and disable voting
    if (payload.dead_player_id === playerId) {
        guesserDead = true;
        // Disable all vote buttons and guesser buttons
        document.querySelectorAll('.vote-btn, .guesser-guess-btn, #skip-vote-btn').forEach(btn => {
            btn.disabled = true;
        });
        meetingState.hasVoted = true;
        // Show death overlay
        showMeetingDeathOverlay(payload);
    } else {
        // Show toast to everyone else
        showError(payload.message);
    }

    // Strike through dead player's name for ALL voters (regardless of correct/wrong guess)
    if (payload.dead_player_id) {
        const wrappers = document.querySelectorAll('.vote-btn-wrapper');
        wrappers.forEach(w => {
            const voteBtn = w.querySelector('.vote-btn');
            if (voteBtn && voteBtn.textContent.trim() === payload.dead_player_name) {
                voteBtn.disabled = true;
                voteBtn.style.textDecoration = 'line-through';
                voteBtn.style.opacity = '0.5';
                const guessBtn = w.querySelector('.guesser-guess-btn');
                if (guessBtn) {
                    guessBtn.disabled = true;
                    guessBtn.style.opacity = '0.5';
                }
            }
        });
    }

    // Update vote count (server scrubs dead player's vote)
    if (payload.votes_cast !== undefined) {
        document.getElementById('votes-cast-count').textContent = payload.votes_cast;
    }
    if (payload.votes_needed !== undefined) {
        document.getElementById('votes-needed-count').textContent = payload.votes_needed;
    }

    // Update allPlayers
    const deadP = allPlayers.find(p => p.id === payload.dead_player_id);
    if (deadP) deadP.status = 'dead';
}

function showMeetingDeathOverlay(payload) {
    // Remove existing overlay if any
    const existing = document.getElementById('meeting-death-overlay');
    if (existing) existing.remove();

    const overlay = document.createElement('div');
    overlay.id = 'meeting-death-overlay';
    overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 3000; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px;';

    const msg = payload.correct
        ? 'You were identified and eliminated!'
        : 'Your guess was wrong. You are dead!';

    overlay.innerHTML = `
        <div style="color: #ef4444; font-size: 32px; font-weight: bold; text-transform: uppercase; text-shadow: 0 0 20px rgba(239,68,68,0.5);">YOU ARE DEAD</div>
        <div style="color: #94a3b8; font-size: 16px; max-width: 280px; text-align: center;">${msg}</div>
        <button onclick="this.parentElement.remove()" class="btn" style="margin-top: 16px; background: #6b7280; padding: 10px 32px; font-size: 16px;">DISMISS</button>
    `;
    document.body.appendChild(overlay);
}

// ==================== NOISE MAKER ====================

function showNoiseMakerSelect() {
    const modal = document.getElementById('noise-maker-modal');
    const list = document.getElementById('noise-maker-player-list');

    // Show alive players (excluding self)
    const alivePlayers = allPlayers.filter(p => p.status !== 'dead' && p.id !== playerId);

    list.innerHTML = alivePlayers.map(p => `
        <button class="btn btn-secondary" onclick="selectNoiseMakerTarget('${p.id}')" style="width: 100%; margin-bottom: 6px; font-size: 14px;">
            ${p.name}
        </button>
    `).join('');

    modal.style.display = 'flex';
}

async function selectNoiseMakerTarget(targetId) {
    const modal = document.getElementById('noise-maker-modal');
    const targetPlayer = allPlayers.find(p => p.id === targetId);
    const targetName = targetPlayer ? targetPlayer.name : 'this player';

    if (!confirm(`Select ${targetName}? They will "find" your body and a meeting will be called.`)) return;

    // Disable all buttons in the modal
    modal.querySelectorAll('button').forEach(btn => btn.disabled = true);

    try {
        const resp = await fetch(`/api/games/${gameCode}/ability/noise-maker-select?session_token=${sessionToken}&target_player_id=${targetId}`, {
            method: 'POST'
        });
        if (resp.ok) {
            modal.style.display = 'none';
            // Meeting will be triggered via WebSocket broadcast
        } else {
            const data = await resp.json();
            showError(data.detail || 'Failed to select target');
            modal.querySelectorAll('button').forEach(btn => btn.disabled = false);
        }
    } catch (e) {
        showError('Failed to select target');
        modal.querySelectorAll('button').forEach(btn => btn.disabled = false);
    }
}

let vultureEatenBodyIds = [];  // Track which bodies we've already eaten
let vultureIneligibleBodyIds = [];  // Bodies discovered in meetings or voted out

function updateVultureBodyList() {
    const list = document.getElementById('vulture-body-list');
    if (!list) return;

    // Filter out bodies we've already eaten AND bodies discovered in meetings/voted out
    const deadPlayers = allPlayers.filter(p => p.status === 'dead' && p.id !== playerId && !vultureEatenBodyIds.includes(p.id) && !vultureIneligibleBodyIds.includes(p.id));
    if (deadPlayers.length === 0) {
        list.innerHTML = '<p style="color: var(--text-secondary); text-align: center; font-size: 13px;">No bodies to eat</p>';
        return;
    }

    list.innerHTML = deadPlayers.map(p => `
        <button class="vulture-eat-btn" onclick="vultureEat('${p.id}', '${p.name}')">
            EAT ${p.name.toUpperCase()}
        </button>
    `).join('');
}

async function vultureEat(targetId, targetName) {
    if (!confirm(`Eat ${targetName}'s body? Tell them to act alive until the next meeting.`)) return;

    try {
        const response = await fetch(`/api/games/${gameCode}/ability/vulture-eat?session_token=${sessionToken}&body_player_id=${targetId}`, {
            method: 'POST'
        });
        if (response.ok) {
            const data = await response.json();
            document.getElementById('vulture-count').textContent = data.bodies_eaten || 0;
            // Track eaten body locally so it disappears from the list
            if (!vultureEatenBodyIds.includes(targetId)) {
                vultureEatenBodyIds.push(targetId);
            }
            updateVultureBodyList();
            if (data.vulture_wins) {
                showError('You ate enough bodies! Vulture wins!');
            }
        } else {
            const data = await response.json();
            showError(data.detail || 'Failed to eat body');
        }
    } catch (e) {
        showError('Failed to eat body');
    }
}

function handlePlayerDeath(payload) {
    // Update allPlayers with death status
    const deadPlayer = allPlayers.find(p => p.id === payload.player_id);
    if (deadPlayer) {
        deadPlayer.status = 'dead';
    }

    // If it's a sheriff shot, show the outcome message
    if (payload.cause === 'sheriff_shot' && payload.message) {
        showError(payload.message);  // Using error styling for visibility
    }

    // Check if the dead player is us
    if (payload.player_id === playerId) {
        document.getElementById('im-dead-btn').disabled = true;
        document.getElementById('im-dead-btn').textContent = 'YOU ARE DEAD';
        document.getElementById('call-meeting-btn').disabled = true;
        document.getElementById('report-body-btn').disabled = true;
    }

    // Update bounty kill button if we're bounty hunter and our target died
    if (myRole === 'Rampager') {
        updateBountyKillButton();
    }

    // Update vulture body list if we're a vulture
    if (myRole === 'Vulture') {
        // Voted-out players are ineligible for vulture eating
        if (payload.cause === 'voted_out' && !vultureIneligibleBodyIds.includes(payload.player_id)) {
            vultureIneligibleBodyIds.push(payload.player_id);
        }
        updateVultureBodyList();
    }

    refreshGame();
}

function handleGameEnd(payload) {
    // Clear any active sabotage UI/timer so it doesn't trigger after game ends
    activeSabotage = null;
    document.getElementById('sabotage-alert').style.display = 'none';
    if (sabotageTimerInterval) {
        clearInterval(sabotageTimerInterval);
        sabotageTimerInterval = null;
    }

    document.getElementById('winner-text').textContent = payload.winner.toUpperCase() + 'S WIN!';

    document.getElementById('roles-list').innerHTML = payload.roles.map(p => `
        <div class="role-reveal-item">
            <span class="player-name">${p.name}</span>
            <span class="player-role role-${p.role?.toLowerCase().replace(' ', '-')}">${p.role || 'Unknown'}</span>
        </div>
    `).join('');

    showScreen('gameover-screen');

    // Play appropriate win sound based on winner
    const winner = payload.winner.toLowerCase();
    if (winner === 'crewmate') {
        playSound('sound-crewmate-win');
    } else if (winner === 'impostor') {
        playSound('sound-impostor-win');
    } else if (winner === 'jester') {
        playSound('sound-jester-win');
    } else if (winner === 'lone wolf') {
        playSound('sound-lonewolf-win');
    } else if (winner === 'vulture') {
        playSound('sound-vulture-win');
    }

    // Vibrate
    if (navigator.vibrate) navigator.vibrate([500]);
}

function returnToLobby() {
    localStorage.removeItem('session_token');
    localStorage.removeItem('player_id');
    // Keep player_name in localStorage for next game
    window.location.href = '/';
}

async function leaveGame() {
    if (!confirm('Are you sure you want to leave this game?')) return;

    try {
        const response = await fetch(`/api/games/${gameCode}/leave?session_token=${sessionToken}`, {
            method: 'POST'
        });

        if (response.ok) {
            localStorage.removeItem('session_token');
            localStorage.removeItem('player_id');
            // Keep player_name for next game
            window.location.href = '/';
        } else {
            const data = await response.json();
            showError(data.detail || 'Failed to leave game');
        }
    } catch (e) {
        showError('Connection error');
    }
}

async function refreshGame() {
    try {
        const response = await fetch(`/api/games/${gameCode}?session_token=${sessionToken}`);
        const data = await response.json();

        allPlayers = data.players;
        updatePlayers(data.players);
        settings = data.settings;
        availableTasks = data.available_tasks || [];
        updateSettingsUI();
        updateTasksUI();
        updateProgress(data.task_percentage);
    } catch (e) {
        console.error('Failed to refresh game:', e);
    }
}

// Task Management Functions
function toggleTaskList() {
    const content = document.getElementById('task-management-content');
    const icon = document.getElementById('task-toggle-icon');
    if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.textContent = '-';
    } else {
        content.style.display = 'none';
        icon.textContent = '+';
    }
}

function updateTasksUI() {
    const list = document.getElementById('available-tasks-list');
    if (!list) return;

    list.innerHTML = availableTasks.map(task => `
        <div class="available-task-item">
            <span>${task}</span>
            <button class="btn-remove" onclick="removeTask('${task}')">&times;</button>
        </div>
    `).join('');
}

async function addTask() {
    const input = document.getElementById('new-task-input');
    const taskName = input.value.trim();
    if (!taskName) return;

    try {
        await fetch(`/api/games/${gameCode}/tasks?session_token=${sessionToken}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ task_name: taskName })
        });
        input.value = '';
    } catch (e) {
        showError('Failed to add task');
    }
}

async function removeTask(taskName) {
    try {
        await fetch(`/api/games/${gameCode}/tasks/${encodeURIComponent(taskName)}?session_token=${sessionToken}`, {
            method: 'DELETE'
        });
    } catch (e) {
        showError('Failed to remove task');
    }
}

// Kill Cooldown Timer Functions
function showCooldownTimer() {
    const timerSection = document.getElementById('cooldown-timer');

    // Show timer for Impostor, Rampager, Sheriff, or Lone Wolf
    if (KILL_COOLDOWN_ROLES.includes(myRole)) {
        timerSection.style.display = 'block';
    } else {
        timerSection.style.display = 'none';
    }
}

function getCooldownForRole() {
    // Return role-specific cooldown
    if (myRole === 'Impostor') {
        return settings.impostor_kill_cooldown || settings.kill_cooldown || 30;
    } else if (myRole === 'Rampager') {
        // Base impostor cooldown minus 5s per bounty kill, minimum 10s
        const base = settings.impostor_kill_cooldown || settings.kill_cooldown || 30;
        return Math.max(10, base - (5 * bountyKills));
    } else if (myRole === 'Sheriff') {
        return settings.sheriff_shoot_cooldown || settings.kill_cooldown || 30;
    } else if (myRole === 'Lone Wolf') {
        return settings.lone_wolf_kill_cooldown || settings.kill_cooldown || 30;
    }
    return settings.kill_cooldown || 30;
}

function startCooldown() {
    const cooldownSeconds = getCooldownForRole();
    cooldownEndTime = Date.now() + (cooldownSeconds * 1000);

    document.getElementById('start-cooldown-btn').style.display = 'none';
    updateCooldownDisplay();

    if (killCooldownTimer) clearInterval(killCooldownTimer);
    killCooldownTimer = setInterval(updateCooldownDisplay, 100);
}

function updateCooldownDisplay() {
    const cooldownText = document.getElementById('cooldown-text');
    const startBtn = document.getElementById('start-cooldown-btn');

    if (!cooldownEndTime) {
        cooldownText.textContent = 'Kill Ready';
        cooldownText.classList.add('ready');
        startBtn.style.display = 'inline-block';
        return;
    }

    const remaining = cooldownEndTime - Date.now();

    if (remaining <= 0) {
        // Cooldown finished
        cooldownEndTime = null;
        clearInterval(killCooldownTimer);
        killCooldownTimer = null;

        cooldownText.textContent = 'KILL READY!';
        cooldownText.classList.add('ready');
        startBtn.style.display = 'inline-block';

        // Vibrate to notify (if enabled)
        if (settings.vibrate_cooldown && navigator.vibrate) {
            navigator.vibrate([100, 50, 100, 50, 100]);
        }
    } else {
        // Still on cooldown
        const seconds = Math.ceil(remaining / 1000);
        cooldownText.textContent = `Kill Cooldown: ${seconds}s`;
        cooldownText.classList.remove('ready');
    }
}

// Rules Modal Functions
function showRules() {
    // Update which rules are visible based on settings
    document.getElementById('rule-jester').style.display = settings.enable_jester ? 'block' : 'none';
    document.getElementById('rule-lonewolf').style.display = settings.enable_lone_wolf ? 'block' : 'none';
    document.getElementById('rule-minion').style.display = settings.enable_minion ? 'block' : 'none';
    document.getElementById('rule-sheriff').style.display = settings.enable_sheriff ? 'block' : 'none';

    document.getElementById('rules-modal').style.display = 'flex';
}

function hideRules() {
    document.getElementById('rules-modal').style.display = 'none';
}

// Map Gallery Functions
let currentMapIndex = 0;

function showMapGallery() {
    document.getElementById('map-modal').style.display = 'flex';
    goToMapSlide(0);
}

function hideMapGallery() {
    document.getElementById('map-modal').style.display = 'none';
}

function goToMapSlide(index) {
    const slides = document.querySelectorAll('.map-slide');
    const indicators = document.querySelectorAll('.map-indicator');

    if (index < 0) index = slides.length - 1;
    if (index >= slides.length) index = 0;

    slides.forEach((s, i) => s.classList.toggle('active', i === index));
    indicators.forEach((ind, i) => ind.classList.toggle('active', i === index));
    currentMapIndex = index;
}

function nextMapSlide() {
    goToMapSlide(currentMapIndex + 1);
}

function prevMapSlide() {
    goToMapSlide(currentMapIndex - 1);
}

// ==================== ROLE GUIDE ====================

let roleGuideCache = null;

async function showRoleGuide() {
    document.getElementById('role-guide-modal').style.display = 'flex';

    if (roleGuideCache) {
        renderRoleGuide(roleGuideCache);
        return;
    }

    try {
        const resp = await fetch(`/api/games/${gameCode}/role-guide?session_token=${sessionToken}`);
        if (resp.ok) {
            roleGuideCache = await resp.json();
            renderRoleGuide(roleGuideCache);
        }
    } catch (e) {
        document.getElementById('role-guide-content').innerHTML = '<p style="color: #ef4444;">Failed to load roles</p>';
    }
}

function renderRoleGuide(guide) {
    const container = document.getElementById('role-guide-content');
    let html = '';

    const sections = [
        { key: 'crew', title: 'Crew', color: '#4ade80' },
        { key: 'impostor', title: 'Impostor', color: '#ef4444' },
        { key: 'neutral', title: 'Neutral', color: '#a855f7' }
    ];

    for (const section of sections) {
        const roles = guide[section.key];
        if (!roles || roles.length === 0) continue;

        html += `<div style="margin-bottom: 15px;">`;
        html += `<h3 style="color: ${section.color}; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">${section.title}</h3>`;

        for (const role of roles) {
            html += `
                <div class="role-guide-item" onclick="this.querySelector('.role-guide-desc').classList.toggle('expanded')" style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 10px; margin-bottom: 6px; cursor: pointer;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: ${role.color}; font-weight: bold;">${role.name}</span>
                        <span style="color: #94a3b8; font-size: 12px;">${role.short}</span>
                    </div>
                    <div class="role-guide-desc" style="color: #cbd5e1; font-size: 13px; margin-top: 0; max-height: 0; overflow: hidden; transition: max-height 0.2s, margin-top 0.2s;">
                        ${role.description}
                    </div>
                </div>
            `;
        }
        html += `</div>`;
    }

    container.innerHTML = html;
}

function hideRoleGuide() {
    document.getElementById('role-guide-modal').style.display = 'none';
}

// Close modal when clicking outside
document.addEventListener('click', (e) => {
    const rulesModal = document.getElementById('rules-modal');
    const mapModal = document.getElementById('map-modal');
    const roleGuideModal = document.getElementById('role-guide-modal');
    if (e.target === rulesModal) {
        hideRules();
    }
    if (e.target === mapModal) {
        hideMapGallery();
    }
    if (e.target === roleGuideModal) {
        hideRoleGuide();
    }
});

function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
    document.getElementById(screenId).style.display = 'block';
}

function showError(msg) {
    const el = document.getElementById('error-message');
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(() => el.style.display = 'none', 3000);
}

// Initialize
connectWS();
refreshGame();

// Keepalive ping
setInterval(() => {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'ping' }));
    }
}, 30000);
</script>
{% endblock %}
